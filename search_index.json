[
["index.html", "Go course Preface", " Go course Petr Shevtsov 2019-06-24 Preface The course is targeted at a beginner level student new to Go but might be familiar with 1-2 other languages (e.g. Python, HTML). "],
["1-basic-concepts.html", "Module 1 Basic concepts ", " Module 1 Basic concepts "],
["1-1-what-is-go.html", "1.1 What is Go?", " 1.1 What is Go? 1.1.1 Welcome to Go Go is a general purpose programming language. It was designed as a “C for the 21st century” with scalability and concurrency in mind. It belongs to the C-family, like C++, Java and C#. It also has characteristics of a dynamic language, so Ruby or Python programmers would also find it comfortable to work with. Go is used to create computer programs. Anything from graphics and mobile application to machine learning and networked servers can be written in Go. The following notable software pieces are written (or have some parts) written in Go: Docker Kubernetes Dropbox OpenShift YouTube Google Chrome Go is a compiled, statically typed language with garbage collection. What does it mean? Compilation During the compilation the source code you wrote is translated into the low-level language natural to the computer to execute. Compiled languages tend to run faster because they operate closer to the “bare metal”, but sometimes it is unpleasant to work with compiled languages because the compilation can be slow. Compilation speed is on of the Go’s benefits, it was designed to be quick to compile. Static typing Being statically typed means that variables must be of a specific type (text string, number, boolean, list, etc). Using a type system, the compiler is able to detect problems earlier, before the program is actually used. Garbage collection Languages with garbage collectors are able to keep track of variables and free them when they are no longer used. Question Go is a: Client-side scripting language General purpose programming language Machine learning program Question Which of the following is true? Go is an interpreted language Go has garbage collection Go is a dynamically typed language Go compiles into a virtual machine byte code "],
["1-2-hello-world.html", "1.2 Hello, world!", " 1.2 Hello, world! 1.2.1 Your first Go program A “Hello, world!” program is traditionally used to introduce programmers to a programming language. Below is a Go code that outputs “Hello, world!”: package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, world!&quot;) } ## Hello, world! Let’s break down the code to understand each line: package main Every Go file belongs to one (and only one) package. The package to which the code file belongs must be indicated before any other code lines. A standalone executable belongs to package main. import &quot;fmt&quot; This line tells Go that this program needs some elements (in out case the function Println) from the package fmt, which implements formatted I/O analogous to printf and scanf in C. The package names are enclosed within double quotes (&quot;&quot;). function main() { } When the program executes, the first function called will be main() (like in C). The code in functions (or the body) is enclosed between braces: { } The first { must be on the same line as the function declaration! fmt.Println(&quot;Hello, world!&quot;) This line calls the function Println from the package fmt, which prints the string parameter to the console, followed by a newline character \\n. The same result can be obtained with fmt.Print(&quot;Hello, world!\\n&quot;) Question Fill in the blanks to import the fmt package: import &quot;fmt&quot; Question What is the starting point for a computer program written in Go? Main function Fist line package main Question Rearrange the code blocks to form a valid Go program: package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Go is awesome!&quot;) } "],
["1-3-the-go-cli.html", "1.3 The Go CLI", " 1.3 The Go CLI 1.3.1 Getting the tools You can run, save, and share your Go codes on our Code Playground, without installing any additional software. Reference this lesson if you need yo install the software on your computer. Official Go CLI binaries are available for Windows, macOS and Linux. Follow the instructions on the Go site to install all the necessary Go tools on your computer. "],
["1-4-value-types.html", "1.4 Value types", " 1.4 Value types 1.4.1 Boolean type A boolean type contains either true or false. The boolean type is bool Conditional expressions are an example of Boolean type. Question What is the result of 42 == 42 operation? Is it true or false? true 1.4.2 Numeric types Go has the well known types such as int. The length of this type depends on the machine, so on 32-bit machine it is 32 bits while on 64-bit machine it is 64 bits. uint type is like int but it stores unsigned values. This type also has the appropriate length for the machine. However, If you want to be explicit about the length you can use either int32 or uint32. The full list of integers (signed and unsigned) is the following: int8, int16, int64, byte, uint8, uint16, uint32 and uint64. byte is an alias for uint8. For floating point values there is float32 and float64. There is no machine dependent float type. A 64 bit integer or floating point value is always 64 bit, even on 32-bit architectures. Question Which of the following are correct values for numeric types? Select all that apply 1000 true 3.14 “hello” Question Is 3.14 an integer? Yes No 1.4.3 Strings Another important built-in type is string. &quot;a&quot;, &quot;Hello world&quot; or &quot;Καλημέρα κόσμε&quot; are string values. 1.4.4 Runes rune is an alias for int32. It is an UTF-8 encoded code point. The purpose of rune is similar to the char type in C++ but rune in Go may contain a Unicode character while char in C++ contains an ASCII symbol. 1.4.5 Complex numbers Go has native support for complex numbers. Complex numbers types are complex64 and complex128. Question Which of the following are the valid value types in Go? Select all that apply. boolean int float integer32 float64 "],
["1-5-variables.html", "1.5 Variables", " 1.5 Variables 1.5.1 Variable names A variable is a name for an area in memory. Creating a variable reserves a memory location, or a space in memory for storing values. The name of a variable (also called the identifier) in Go is a sequence of letters, digits and underscore character. The first character in a variable name must be a letter or an underscore. For example: x _z5 Letters in Go variable names are not limited to the letters of the Latin alphabet, so the following variable names are also valid: αβ åβč The naming of identifiers for variables follows the camelCase rules (start with a small letter, every new part of the word starts with a capital letter): startDate, wordCount. 1.5.1.1 Predeclared identifiers The following are the predefined identifiers and may not be used as variable names: Types: bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr Constants: true false iota Zero value: nil Functions: append cap close complex copy delete imag len make new panic print println real recover 1.5.1.2 Keywords The following keywords are reserved and may not be used as variable names: break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var Question Which of the following are valid Go variable names? Select all that apply. case a+b x 1a sum 1.5.2 Declaration and assignment Variables can be declared using the var keyword. Go is different from other languages (e.g. C or C++) in that the type of a variable is specified after the variable name. In C: int a; In Go: var a int Multiple variables of the same type can be also declared on a single line: var x, y int. Multiple var declarations may also be grouped: var ( n int s string ) When a variable is declared it contains the default zero or null value for its type: 0 for int, false for bool, empty string (&quot;&quot;) for string, etc. Declaring and assigning variables in Go is a two step process, but they may be combined. The following two pieces of code have the same effect: var a int var b bool a = 42 b = true var a int = 42 var b bool = true Go can infer the type of the declared and assigned variable: var a = 42 // inferred type: int var b = true // inferred type: bool 1.5.3 Short declaration syntax With the type omitted, the keyword var is pretty superfluous, so we may write as the following: a := 42 b := true The types of a and b (int and bool) are inferred by the compiler. You can also make use of parallel assignment: a, b := 42, true Question What is the type of b in the following assignment? var a int b := a int pointer interface{} 1.5.4 Discard assignments A special name for a variable is _ (underscore). Any value assigned to it is discarded: // we only assign the integer value of 36 to b and discard the value 25. _, b := 25, 36 In later sections you’ll learn that Go supports multiple return values from functions. Discard assignments are useful if some of the returned values aren’t needed, so such values can be discarded 1.5.5 Declaration and usage A variable which is used, but not declared, gives a compiler error: package main import &quot;fmt&quot; func main() { fmt.Println(a) } undefined: a Declared but otherwise unused variables are a compiler error in Go: package main func main() { var x int } x declared and not used "],
["1-6-operators.html", "1.6 Operators", " 1.6 Operators Values are combined together with operators into expressions. Every value type has its own defined set of operators, which can work with values of that type. Using an operator for a value type for which it is not defined leads to a compiler error. 1.6.1 Arithmetic operators The common arithmetic operators exist for both integers and floats: + (addition) - (subtraction) * (multiplication) / (division) / for integers is integer division. For example: package main import &quot;fmt&quot; func main() { fmt.Println(9 / 4) } ## 2 The modulus operator % is only defined for integers: package main import &quot;fmt&quot; func main() { fmt.Println(9 % 4) } ## 1 There are shortcuts for these operations: a = a + b can be shortened to a += b, and the same goes for -=, *=, /= and %=. Question What is the value of the result variable? a := 12 b := 5 result := a % b 2 1.6.2 Operator precedence Some operators have higher priority (precedence) than others. Operators of the same precedence are performed from left to right. *, / and % operators have higher precedence, while +, - operators have lower precedence. It is allowed to clarify expressions by using ( ) to indicate priority in operations. Expressions contained in ( ) are always computed first. package main import &quot;fmt&quot; func main() { a := 9 b := 6 c := 3 fmt.Println(a - b + c) fmt.Println(a + b / c) fmt.Println((a + b) / c) } ## 6 ## 11 ## 5 Question Fill in the blanks to subtract b from a and add c to the result. a := 9 b := 6 c := 3 result := a-b+c 1.6.3 Increment and decrement For integers and floats Go has ++ (increment) and -- (decrement) operators: i++ // is short for i += 1 is short for i = i + 1 i-- // is short for i -= 1 is short for i = i - 1 The increment and decrement operators can only be used after the number (postfix). ++ and -- may only be used as statements, not expressions. While n = i++ is accepted in C, C++ and Java, it is invalid in Go. Question Which of the following are correct use of increment and decrement operators in Go? Select all that apply: x = y++ j++ –n f(i++) i– "],
["1-7-constants.html", "1.7 Constants", " 1.7 Constants Constants in Go are created at compile time. Constants can only be numbers, strings or booleans. package main import &quot;fmt&quot; const a = 42 // Constants can be groupped together const ( b = true c = &quot;Hello world&quot; pi = 3.14 ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(pi) } ## 42 ## true ## Hello world ## 3.14 Question Fill in the blanks to define a constant x which equals to 42: const x = 42 1.7.1 iota enumerator You can use iota to enumerate constant values: package main import &quot;fmt&quot; const ( a = iota // 0 b = iota // 1 c = iota // 2 ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) } ## 0 ## 1 ## 2 The first use of iota will yield 0, so a is equal to 0, whenever iota is used again on a new line its value is incremented with 1, so b has a value of 1 and c has the value of 2. This can be shortened to: package main import &quot;fmt&quot; const ( a = iota // 0 b // 1 c // 2 ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) } ## 0 ## 1 ## 2 iota can also be used in expressions: package main import &quot;fmt&quot; const ( a = iota + 10 // 10 b // 11 c // 12 ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) } ## 10 ## 11 ## 12 A new const block initializes iota back to 0: package main import &quot;fmt&quot; const ( a = iota + 10 // 10 b // 11 c // 12 ) const ( _ = iota // ignore first value by assigning to blank identifier x = iota * 10 // 10 y // 20 z // 30 ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(x) fmt.Println(y) fmt.Println(z) } ## 10 ## 11 ## 12 ## 10 ## 20 ## 30 Question What is the value of the constant z? const a = iota const ( _ = iota x = iota * 10 - 3 y z = iota + 42 ) 45 "],
["1-8-comments.html", "1.8 Comments", " 1.8 Comments Comments are explanatory information that you can include in the Go code to explain what the code is doing. The compiler ignores comments, so they have no affect on a program. Go uses C++-style comments: // for single-line comments that finish at the end of the line and /* … */ for comments than can span multiple lines. For example: package main import &quot;fmt&quot; func main() { // Output a string &quot;Hello, world!&quot; fmt.Println(&quot;Hello, world!&quot;) } ## Hello, world! Comments clarify the program’s intent to the reader. Later on you’ll learn how to use comments to produce documentation for the Go code. Question Which of the following indicates a single-line comment? -- single-line comment // single-line comment # single-line comment "],
["1-9-packages-and-imports.html", "1.9 Packages and imports", " 1.9 Packages and imports Packages are a way to structure code. A program in Go is constructed as a package, which may use resourses from other packages. Every Go file belongs to only one package. Go package may consist of multiple Go files. The first line of every Go file indicates the package to which the Go file belongs: package main A stanalone executable belongs to package main. Question Which of the following is true about Go packages. Select all that apply: Packages are used to structure code One Go file may belong to multiple packages Go package may consist of multiple Go files A standalone executable belongs to package application 1.9.1 Go standard library The standard library of Go contains a lot of packages (like fmt, stings, etc). It is also possible to create your own packages. For your own packages, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries. To use exported elements (constants, types, variable and functions) from another package in your package, that another package must be imported using the import keyword: import &quot;fmt&quot; If you need to import multiple packages you can use multiple import statements: import &quot;bytes&quot; import &quot;fmt&quot; import &quot;strings&quot; But the Go idiomatic way of multiple imports is to use import keyword with brackets ( ), the same way as with variables and constants: import ( &quot;bytes&quot; &quot;fmt&quot; &quot;strings&quot; ) Question Which of the following is the correct way to import packages in Go? uses &quot;fmt&quot; import &quot;fmt&quot; #include &lt;fmt&gt; import fmt "],
["try-it-yourself.html", "Try it yourself", " Try it yourself // This is a comment. // Every Go file must be a part of some package. // This file is a part of package main. package main // We import package &quot;fmt&quot; from the standard Go library. import &quot;fmt&quot; // `who` is a constant. const who = &quot;world&quot; // Function main() is the main entry point of any application written in Go. func main() { // We declare `greeting` as a variable of type string and assign the value. var greeting string = &quot;Hello&quot; // We declare `message` variable using the shorthand syntax. The type of // the variable is determined by the assigned value. In our case it is // string type. message := greeting + &quot;, &quot; + who // Let&#39;s print the value of the variable `message` using the function from // the package &quot;fmt&quot;. fmt.Println(message) } ## Hello, world "],
["2-conditionals-and-loops.html", "Module 2 Conditionals and Loops ", " Module 2 Conditionals and Loops "],
["2-1-the-if-statement.html", "2.1 The if statement", " 2.1 The if statement "],
["2-2-the-else-statement.html", "2.2 The else statement", " 2.2 The else statement "],
["2-3-ifelse-chains.html", "2.3 if/else chains", " 2.3 if/else chains "],
["2-4-the-if-statement-with-expression.html", "2.4 The if statement with expression", " 2.4 The if statement with expression "],
["2-5-the-switch-statement.html", "2.5 The switch statement", " 2.5 The switch statement "],
["2-6-the-switch-without-condition.html", "2.6 The switch without condition", " 2.6 The switch without condition "],
["2-7-the-for-statement.html", "2.7 The for statement", " 2.7 The for statement "],
["2-8-the-defer-statement.html", "2.8 The defer statement", " 2.8 The defer statement "],
["module-project.html", "Module project", " Module project package main import &quot;fmt&quot; func main() { // Here we loop from 0 to 99 and only output some sentences for particular // cases. for age := 0; age &lt; 99; age++ { switch age { case 16: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can drive a car!&quot;) case 18: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can buy a lottery ticket!&quot;) case 21: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can buy some beer!&quot;) break default: continue } } } ## When you&#39;re 16 you can drive a car! ## When you&#39;re 18 you can buy a lottery ticket! ## When you&#39;re 21 you can buy some beer! "],
["3-composite-data-types.html", "Module 3 Composite Data Types ", " Module 3 Composite Data Types "],
["3-1-arrays.html", "3.1 Arrays", " 3.1 Arrays "],
["3-2-loops-and-arrays.html", "3.2 Loops and arrays", " 3.2 Loops and arrays "],
["3-3-slices.html", "3.3 Slices", " 3.3 Slices "],
["3-4-appending-items-to-slices.html", "3.4 Appending items to slices", " 3.4 Appending items to slices "],
["3-5-range.html", "3.5 Range", " 3.5 Range "],
["3-6-maps.html", "3.6 Maps", " 3.6 Maps "],
["3-7-arrays-vs-maps.html", "3.7 Arrays vs maps", " 3.7 Arrays vs maps "],
["3-8-structs.html", "3.8 Structs", " 3.8 Structs "],
["3-9-struct-literals.html", "3.9 Struct literals", " 3.9 Struct literals "],
["3-10-operations-with-structs.html", "3.10 Operations with structs", " 3.10 Operations with structs "],
["module-project-1.html", "Module project", " Module project package main import ( &quot;fmt&quot; &quot;strings&quot; ) // Shakespeare contains the text of one of the Shakespeare&#39;s sonets. We&#39;ll use // this text to count words in it. const Shakespeare = ` From fairest creatures we desire increase, That thereby beauty&#39;s rose might never die, But as the riper should by time decease, His tender heir might bear his memory: But thou contracted to thine own bright eyes, Feed&#39;st thy light&#39;s flame with self-substantial fuel, Making a famine where abundance lies, Thy self thy foe, to thy sweet self too cruel: Thou that art now the world&#39;s fresh ornament, And only herald to the gaudy spring, Within thine own bud buriest thy content, And tender churl mak&#39;st waste in niggarding: Pity the world, or else this glutton be, To eat the world&#39;s due, by the grave and thee. ` // getWord returns a word in lower case and with trimmed punctuation. func getWord(s string) string { return strings.ToLower(strings.Trim(s, &quot;,:.&quot;)) } func main() { wordCount := make(map[string]int) // Here we loop through the slice of words produced using strings.Fields // function. That function splits text into a slice of strings using // space-characters: whitespaces, tabs, new line symbols, etc. for _, word := range strings.Fields(Shakespeare) { // Trim punctuation and make it lower case. word = getWord(word) // Increase the count. If the there was no such word in the map it uses // zero as its count. wordCount[word]++ } // Loop through the map and print its keys and values. for word, count := range wordCount { fmt.Println(word, count) } } ## lies 1 ## churl 1 ## fairest 1 ## desire 1 ## should 1 ## thy 5 ## abundance 1 ## time 1 ## thou 2 ## with 1 ## self 2 ## gaudy 1 ## now 1 ## world&#39;s 2 ## die 1 ## the 6 ## bear 1 ## sweet 1 ## too 1 ## light&#39;s 1 ## mak&#39;st 1 ## world 1 ## this 1 ## fuel 1 ## ornament 1 ## else 1 ## due 1 ## thee 1 ## content 1 ## pity 1 ## creatures 1 ## increase 1 ## beauty&#39;s 1 ## contracted 1 ## to 4 ## tender 2 ## thine 2 ## eyes 1 ## waste 1 ## bright 1 ## only 1 ## buriest 1 ## that 2 ## thereby 1 ## never 1 ## as 1 ## memory 1 ## or 1 ## famine 1 ## glutton 1 ## grave 1 ## from 1 ## where 1 ## spring 1 ## be 1 ## feed&#39;st 1 ## making 1 ## within 1 ## in 1 ## niggarding 1 ## we 1 ## by 2 ## self-substantial 1 ## and 3 ## herald 1 ## rose 1 ## might 2 ## own 2 ## decease 1 ## cruel 1 ## art 1 ## foe 1 ## fresh 1 ## bud 1 ## but 2 ## riper 1 ## his 2 ## flame 1 ## a 1 ## heir 1 ## eat 1 "],
["4-functions-and-pointers.html", "Module 4 Functions and pointers ", " Module 4 Functions and pointers "],
["4-1-function-declaration.html", "4.1 Function declaration", " 4.1 Function declaration "],
["4-2-functions-parameters.html", "4.2 Functions parameters", " 4.2 Functions parameters "],
["4-3-return-values.html", "4.3 Return values", " 4.3 Return values "],
["4-4-error-handling.html", "4.4 Error handling", " 4.4 Error handling "],
["4-5-variadic-functions.html", "4.5 Variadic functions", " 4.5 Variadic functions "],
["4-6-iteration-and-recursion.html", "4.6 Iteration and recursion", " 4.6 Iteration and recursion "],
["4-7-anonymous-functions.html", "4.7 Anonymous functions", " 4.7 Anonymous functions "],
["4-8-panic.html", "4.8 Panic", " 4.8 Panic "],
["4-9-pointers.html", "4.9 Pointers", " 4.9 Pointers "],
["4-10-functions-and-pointers-1.html", "4.10 Functions and pointers", " 4.10 Functions and pointers "],
["module-project-2.html", "Module project", " Module project package main import &quot;fmt&quot; // fibonacci returns the nth Fibonacci number. func fibonacci(n int) int { if n &lt; 2 { return n } return fibonacci(n-1) + fibonacci(n-2) } // fibonacciSequence changes the int slice to make it contain the Fibonacci // numbers according to its keys. This function operates on the actual slice, // that&#39;s why it does not return anything. func fibonacciSequence(slice []int) { for n := range slice { slice[n] = fibonacci(n) } } func main() { // Create an empty int slice of length 10 sequence := make([]int, 10) // Fill the slice with Fibonacci numbers secuence fibonacciSequence(sequence) fmt.Println(sequence) } ## [0 1 1 2 3 5 8 13 21 34] "],
["5-methods.html", "Module 5 Methods ", " Module 5 Methods "],
["5-1-method-declarations.html", "5.1 Method declarations", " 5.1 Method declarations "],
["5-2-methods-with-a-pointer-receiver.html", "5.2 Methods with a pointer receiver", " 5.2 Methods with a pointer receiver "],
["5-3-composing-types-with-structs.html", "5.3 Composing types with structs", " 5.3 Composing types with structs "],
["5-4-working-with-struct-methods.html", "5.4 Working with struct methods", " 5.4 Working with struct methods "],
["5-5-method-values.html", "5.5 Method values", " 5.5 Method values "],
["5-6-method-expressions.html", "5.6 Method expressions", " 5.6 Method expressions "],
["5-7-encapsulation.html", "5.7 Encapsulation", " 5.7 Encapsulation "],
["module-project-3.html", "Module project", " Module project package main import ( &quot;fmt&quot; ) // printer is a struct with no fields. It only has a method. type printer struct{} // receipt is a variadic function. It can be called with any number of // arguments, just like fmt.Println() func (p printer) receipt(a ...interface{}) { fmt.Println(a...) } // Account represents a bank account data structure, it has one field and an // embedded struct. type Account struct { balance int printer } // NewAccount created a new Account setting the initial balance. func NewAccount(balance int) *Account { return &amp;Account{ balance: balance, } } // Deposit increases the account balance by the specified amount. // It prints the information about the operation using the method of the // embedded printer struct. func (a *Account) Deposit(amount int) { a.receipt(&quot;--&gt; trying to deposit&quot;, amount) a.balance = a.balance + amount } // Withdraw checks if the account balance is not lesser than the amount to // withdraw and decreses the balance by the specified amount. // It prints the information about the operation using the method of the // embedded printer struct. func (a *Account) Withdraw(amount int) { a.receipt(&quot;&lt;-- trying to withdraw&quot;, amount) if amount &gt; a.balance { a.receipt(&quot;Withdraw error: not enough funds to withdraw&quot;, amount) return } a.balance = a.balance - amount } // Balance outputs the account balance using the Method of the embedded printer // struct. func (a Account) Balance() { a.receipt(&quot;Account balance:&quot;, a.balance) } func main() { account := NewAccount(100) account.Balance() account.Withdraw(25) account.Balance() account.Deposit(50) account.Balance() account.Withdraw(1000) account.Balance() } ## Account balance: 100 ## &lt;-- trying to withdraw 25 ## Account balance: 75 ## --&gt; trying to deposit 50 ## Account balance: 125 ## &lt;-- trying to withdraw 1000 ## Withdraw error: not enough funds to withdraw 1000 ## Account balance: 125 "],
["6-interfaces.html", "Module 6 Interfaces ", " Module 6 Interfaces "],
["6-1-introduction.html", "6.1 Introduction", " 6.1 Introduction "],
["6-2-interface-types.html", "6.2 Interface types", " 6.2 Interface types "],
["6-3-satisfaction.html", "6.3 Satisfaction", " 6.3 Satisfaction "],
["6-4-flag-value.html", "6.4 flag.Value", " 6.4 flag.Value "],
["6-5-interface-values.html", "6.5 Interface values", " 6.5 Interface values "],
["6-6-sorting-with-sort-interface.html", "6.6 Sorting with sort.Interface", " 6.6 Sorting with sort.Interface "],
["6-7-the-error-interface.html", "6.7 The error interface", " 6.7 The error interface "],
["6-8-type-assertions.html", "6.8 Type assertions", " 6.8 Type assertions "],
["6-9-type-switches.html", "6.9 Type switches", " 6.9 Type switches "],
["module-project-4.html", "Module project", " Module project package main import ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;sort&quot; &quot;strings&quot; ) // Shakespeare contains the text of one of the Shakespeare&#39;s sonets. We&#39;ll use // this text to count words in it. const Shakespeare = ` From fairest creatures we desire increase, That thereby beauty&#39;s rose might never die, But as the riper should by time decease, His tender heir might bear his memory: But thou contracted to thine own bright eyes, Feed&#39;st thy light&#39;s flame with self-substantial fuel, Making a famine where abundance lies, Thy self thy foe, to thy sweet self too cruel: Thou that art now the world&#39;s fresh ornament, And only herald to the gaudy spring, Within thine own bud buriest thy content, And tender churl mak&#39;st waste in niggarding: Pity the world, or else this glutton be, To eat the world&#39;s due, by the grave and thee. ` // WordCountPair is a record of word and its count. type WordCountPair struct { Word string Count int } // getWord returns a word in lower case and with trimmed punctuation. func getWord(s string) string { return strings.ToLower(strings.Trim(s, &quot;,:.&quot;)) } // Functions can be types too! type lessFunc func(p1, p2 *WordCountPair) bool // multiSorter implements the Sort interface, sorting the word-count pairs. type multiSorter struct { wordCountPairs []WordCountPair less []lessFunc } // Sort sorts the argument slice according to the less functions passed to // OrderedBy. func (ms *multiSorter) Sort(wordCountPairs []WordCountPair) { ms.wordCountPairs = wordCountPairs sort.Sort(ms) } // OrderedBy returns a Sorter that sorts using the less functions, in order. // Call its Sort method to sort the data. func OrderedBy(less ...lessFunc) *multiSorter { return &amp;multiSorter{ less: less, } } // Len is part of sort.Interface. func (ms *multiSorter) Len() int { return len(ms.wordCountPairs) } // Swap is part of sort.Interface. func (ms *multiSorter) Swap(i, j int) { ms.wordCountPairs[i], ms.wordCountPairs[j] = ms.wordCountPairs[j], ms.wordCountPairs[i] } // Less is part of sort.Interface. It is implemented by looping along the less // functions until it finds a comparison the discriminates between the two items // (one is less than the other). func (ms *multiSorter) Less(i, j int) bool { p, q := &amp;ms.wordCountPairs[i], &amp;ms.wordCountPairs[j] // Try all but the last comparison. var k int for k = 0; k &lt; len(ms.less)-1; k++ { less := ms.less[k] switch { case less(p, q): // p &lt; q, so we have a decision. return true case less(q, p): // p &gt; q, so we have a decision. return false } // p == q; try the next comparison. } // All comparisons to here said &quot;equal&quot;, so just return whatever the final // comparison reports. return ms.less[k](p, q) } // WordCount counts words read from input (io.Reader interface) and returns the // word-count pairs. func WordCount(input io.Reader) []WordCountPair { m := make(map[string]int) scanner := bufio.NewScanner(input) scanner.Split(bufio.ScanWords) for scanner.Scan() { // Read a word using word scanner, trim punctuation and make it lower case. word := getWord(scanner.Text()) // Increase the count. If the there was no such word in the map it uses // zero as its count. m[word]++ } // Create a slice the same length as the word-count map. pairs := make([]WordCountPair, len(m)) // Fill the silce with data from the map. i := 0 for word, count := range m { pairs[i] = WordCountPair{Word: word, Count: count} i++ } return pairs } func main() { input := strings.NewReader(Shakespeare) pairs := WordCount(input) // Closures that order the WordCountPair structure. word := func(p1, p2 *WordCountPair) bool { return p1.Word &lt; p2.Word } count := func(p1, p2 *WordCountPair) bool { return p1.Count &gt; p2.Count // Note: &gt; orders downward. } OrderedBy(count, word).Sort(pairs) for _, pair := range pairs { fmt.Println(pair.Word, pair.Count) } } ## the 6 ## thy 5 ## to 4 ## and 3 ## but 2 ## by 2 ## his 2 ## might 2 ## own 2 ## self 2 ## tender 2 ## that 2 ## thine 2 ## thou 2 ## world&#39;s 2 ## a 1 ## abundance 1 ## art 1 ## as 1 ## be 1 ## bear 1 ## beauty&#39;s 1 ## bright 1 ## bud 1 ## buriest 1 ## churl 1 ## content 1 ## contracted 1 ## creatures 1 ## cruel 1 ## decease 1 ## desire 1 ## die 1 ## due 1 ## eat 1 ## else 1 ## eyes 1 ## fairest 1 ## famine 1 ## feed&#39;st 1 ## flame 1 ## foe 1 ## fresh 1 ## from 1 ## fuel 1 ## gaudy 1 ## glutton 1 ## grave 1 ## heir 1 ## herald 1 ## in 1 ## increase 1 ## lies 1 ## light&#39;s 1 ## mak&#39;st 1 ## making 1 ## memory 1 ## never 1 ## niggarding 1 ## now 1 ## only 1 ## or 1 ## ornament 1 ## pity 1 ## riper 1 ## rose 1 ## self-substantial 1 ## should 1 ## spring 1 ## sweet 1 ## thee 1 ## thereby 1 ## this 1 ## time 1 ## too 1 ## waste 1 ## we 1 ## where 1 ## with 1 ## within 1 ## world 1 "],
["7-goroutines-and-channels.html", "Module 7 Goroutines and channels ", " Module 7 Goroutines and channels "],
["7-1-what-is-goroutine.html", "7.1 What is goroutine", " 7.1 What is goroutine "],
["7-2-introduction-to-concurrency.html", "7.2 Introduction to concurrency", " 7.2 Introduction to concurrency "],
["7-3-channels.html", "7.3 Channels", " 7.3 Channels "],
["7-4-types-of-channels.html", "7.4 Types of channels", " 7.4 Types of channels "],
["7-5-pipelines.html", "7.5 Pipelines", " 7.5 Pipelines "],
["7-6-looping-in-parallel.html", "7.6 Looping in parallel", " 7.6 Looping in parallel "],
["7-7-time-tick.html", "7.7 time.Tick", " 7.7 time.Tick "],
["7-8-the-select-statement.html", "7.8 The select statement", " 7.8 The select statement "],
["7-9-cancellation.html", "7.9 Cancellation", " 7.9 Cancellation "],
["module-project-5.html", "Module project", " Module project package main import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot; ) const ( NumberOfRacers = 10 NumberOfLaps = 3 MaxSleepDuration = 3 // seconds ) func init() { rand.Seed(time.Now().UnixNano()) } func race(racer int, start chan struct{}, finish chan int, status chan []int, wg *sync.WaitGroup) { defer wg.Done() &lt;-start for lap := 1; lap &lt;= NumberOfLaps; lap++ { sleep := time.Duration(rand.Intn(MaxSleepDuration)) time.Sleep(sleep * time.Second) go func(racer, lap int) { status &lt;- []int{racer, lap} }(racer, lap) } finish &lt;- racer } func main() { start := make(chan struct{}) finish := make(chan int) status := make(chan []int) done := make(chan struct{}) var wg sync.WaitGroup wg.Add(NumberOfRacers) for racer := 1; racer &lt;= NumberOfRacers; racer++ { go race(racer, start, finish, status, &amp;wg) } go func() { wg.Wait() close(done) }() startTime := time.Now() close(start) ticker := time.NewTicker(time.Second) defer ticker.Stop() var winners []int OuterLoop: for { select { case t := &lt;-ticker.C: fmt.Println(&quot;Race time:&quot;, t.Sub(startTime)) case s := &lt;-status: fmt.Printf(&quot;Racer #%d is on lap %d\\n&quot;, s[0], s[1]) case finished := &lt;-finish: fmt.Printf(&quot;Racer #%d finished!\\n&quot;, finished) if len(winners) &lt; 3 { winners = append(winners, finished) } case &lt;-done: break OuterLoop } } close(finish) close(status) fmt.Println(&quot;\\nWinners:&quot;) place := 1 for _, racer := range winners { fmt.Printf(&quot;%d place: Racer #%d\\n&quot;, place, racer) place++ } } ## Racer #1 finished! ## Racer #10 finished! ## Racer #3 is on lap 1 ## Racer #4 is on lap 1 ## Racer #7 is on lap 1 ## Racer #8 is on lap 1 ## Racer #9 is on lap 1 ## Racer #10 is on lap 3 ## Racer #10 is on lap 1 ## Racer #10 is on lap 2 ## Racer #1 is on lap 2 ## Racer #1 is on lap 1 ## Racer #1 is on lap 3 ## Race time: 1.000275906s ## Racer #6 finished! ## Racer #6 is on lap 3 ## Racer #2 is on lap 2 ## Racer #3 is on lap 2 ## Racer #4 is on lap 2 ## Racer #5 is on lap 1 ## Racer #6 is on lap 1 ## Racer #6 is on lap 2 ## Racer #2 is on lap 1 ## Race time: 2.000324112s ## Racer #9 is on lap 2 ## Racer #7 is on lap 2 ## Racer #8 is on lap 2 ## Racer #5 finished! ## Racer #3 finished! ## Racer #4 finished! ## Racer #5 is on lap 2 ## Racer #5 is on lap 3 ## Racer #3 is on lap 3 ## Racer #4 is on lap 3 ## Race time: 3.000191902s ## Racer #7 finished! ## Racer #2 finished! ## Racer #9 finished! ## Racer #7 is on lap 3 ## Racer #2 is on lap 3 ## Racer #9 is on lap 3 ## Race time: 4.000195856s ## Racer #8 finished! ## Racer #8 is on lap 3 ## ## Winners: ## 1 place: Racer #1 ## 2 place: Racer #10 ## 3 place: Racer #6 "],
["course-project.html", "Course project", " Course project package main import ( &quot;encoding/csv&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot; ) func main() { var input io.Reader switch len(os.Args) { case 1: input = os.Stdin case 2: f, err := os.Open(os.Args[1]) if err != nil { log.Fatal(err) } defer f.Close() input = f default: log.Fatal(&quot;This program expects either 0 or 1 arguments.&quot;) } r := csv.NewReader(input) r.FieldsPerRecord = -1 records, err := r.ReadAll() if err != nil { log.Fatal(err) } // Remove the very first &quot;record&quot; (i.e &#39;Category: All categories&#39;) if exists if len(records[0]) == 1 { records = append(records[:0], records[1:]...) } // Save names to a slice names := records[0][1:] // Skip &#39;weeks&#39; column commonSuffix := longestCommonSuffix(names) if commonSuffix != &quot;&quot; { for i, name := range names { names[i] = strings.TrimSuffix(name, commonSuffix) } } records = append(records[:0], records[1:]...) avg := make([]int, len(names)) for _, record := range records { record = record[1:] // Skip &#39;weeks&#39; column for i, s := range record { n, err := strconv.Atoi(s) if err != nil { log.Fatal(err) } avg[i] += n } } for i := 0; i &lt; len(avg); i++ { avg[i] = avg[i] / len(records) } for i, n := range avg { n = n/10 + 1 fmt.Printf(&quot;%s %s (%d)\\n&quot;, strings.Repeat(&quot;▓&quot;, n), names[i], avg[i]) } } func longestCommonSuffix(a []string) string { if len(a) == 0 { return &quot;&quot; } suffix := a[0] if len(a) == 1 { return suffix } for _, s := range a[1:] { suffixLength := len(suffix) sLength := len(s) if suffixLength == 0 || sLength == 0 { return &quot;&quot; } maxLength := suffixLength if sLength &lt; maxLength { maxLength = sLength } for i := 0; i &lt; maxLength; i++ { j := suffixLength - i - 1 k := sLength - i - 1 if suffix[j] != s[k] { suffix = suffix[j+1:] break } } } return suffix } "]
]
