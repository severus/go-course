[
["index.html", "Go course Preface", " Go course Petr Shevtsov 2019-05-13 Preface The course is targeted at a beginner level student new to Go but might be familiar with 1-2 other languages (e.g.Â Python, HTML). "],
["basic-concepts.html", "Module 1 Basic Concepts 1.1 What is Go? 1.2 Hello, world! 1.3 The Go CLI 1.4 Value types 1.5 Variables 1.6 Operators 1.7 Constants 1.8 Comments 1.9 Packages and imports Module project", " Module 1 Basic Concepts 1.1 What is Go? 1.2 Hello, world! 1.3 The Go CLI 1.4 Value types 1.5 Variables 1.6 Operators 1.7 Constants 1.8 Comments 1.9 Packages and imports Module project // This is a comment. // Every Go file must be a part of some package. // This file is a part of package main. package main // We import package &quot;fmt&quot; from the standard Go library. import &quot;fmt&quot; // `who` is a constant. const who = &quot;world&quot; // Function main() is the main entry point of any application written in Go. func main() { // We declare `greeting` as a variable of type string and assign the value. var greeting string = &quot;Hello&quot; // We declare `message` variable using the shorthand syntax. The type of // the variable is determined by the assigned value. In our case it is // string type. message := greeting + &quot;, &quot; + who // Let&#39;s print the value of the variable `message` using the function from // the package &quot;fmt&quot;. fmt.Println(message) } ## Hello, world "],
["conditionals-and-loops.html", "Module 2 Conditionals and Loops 2.1 The if statement 2.2 The else statement 2.3 if/else chains 2.4 The if statement with expression 2.5 The switch statement 2.6 The switch without condition 2.7 The for statement 2.8 The defer statement Module project", " Module 2 Conditionals and Loops 2.1 The if statement 2.2 The else statement 2.3 if/else chains 2.4 The if statement with expression 2.5 The switch statement 2.6 The switch without condition 2.7 The for statement 2.8 The defer statement Module project package main import &quot;fmt&quot; func main() { for age := 0; age &lt; 99; age++ { switch age { case 16: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can drive a car!&quot;) case 18: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can buy a lottery ticket!&quot;) case 21: fmt.Println(&quot;When you&#39;re&quot;, age, &quot;you can buy some beer!&quot;) break default: continue } } } ## When you&#39;re 16 you can drive a car! ## When you&#39;re 18 you can buy a lottery ticket! ## When you&#39;re 21 you can buy some beer! "],
["composite-data-types.html", "Module 3 Composite Data Types 3.1 Arrays 3.2 Loops and arrays 3.3 Slices 3.4 Appending items to slices 3.5 Range 3.6 Maps 3.7 Arrays vs maps 3.8 Structs 3.9 Struct literals 3.10 Operations with structs Module project", " Module 3 Composite Data Types 3.1 Arrays 3.2 Loops and arrays 3.3 Slices 3.4 Appending items to slices 3.5 Range 3.6 Maps 3.7 Arrays vs maps 3.8 Structs 3.9 Struct literals 3.10 Operations with structs Module project package main import ( &quot;fmt&quot; &quot;strings&quot; ) const Shakespeare = ` From fairest creatures we desire increase, That thereby beauty&#39;s rose might never die, But as the riper should by time decease, His tender heir might bear his memory: But thou contracted to thine own bright eyes, Feed&#39;st thy light&#39;s flame with self-substantial fuel, Making a famine where abundance lies, Thy self thy foe, to thy sweet self too cruel: Thou that art now the world&#39;s fresh ornament, And only herald to the gaudy spring, Within thine own bud buriest thy content, And tender churl mak&#39;st waste in niggarding: Pity the world, or else this glutton be, To eat the world&#39;s due, by the grave and thee. ` func main() { wordCount := make(map[string]int) for _, word := range strings.Fields(Shakespeare) { word = strings.Trim(word, &quot;,:.&quot;) word = strings.ToLower(word) count := wordCount[word] count++ wordCount[word] = count } for word, count := range wordCount { fmt.Println(word, count) } } ## time 1 ## heir 1 ## art 1 ## in 1 ## from 1 ## rose 1 ## riper 1 ## flame 1 ## ornament 1 ## spring 1 ## decease 1 ## feed&#39;st 1 ## bud 1 ## niggarding 1 ## desire 1 ## by 2 ## buriest 1 ## glutton 1 ## eat 1 ## contracted 1 ## own 2 ## lies 1 ## abundance 1 ## only 1 ## within 1 ## never 1 ## but 2 ## to 4 ## eyes 1 ## too 1 ## content 1 ## world 1 ## creatures 1 ## increase 1 ## die 1 ## world&#39;s 2 ## gaudy 1 ## waste 1 ## else 1 ## this 1 ## thereby 1 ## his 2 ## cruel 1 ## a 1 ## where 1 ## herald 1 ## bear 1 ## bright 1 ## light&#39;s 1 ## tender 2 ## making 1 ## fresh 1 ## thee 1 ## fairest 1 ## we 1 ## as 1 ## thine 2 ## thy 5 ## sweet 1 ## mak&#39;st 1 ## the 6 ## should 1 ## with 1 ## pity 1 ## memory 1 ## now 1 ## churl 1 ## fuel 1 ## beauty&#39;s 1 ## thou 2 ## self-substantial 1 ## foe 1 ## or 1 ## due 1 ## that 2 ## might 2 ## self 2 ## grave 1 ## famine 1 ## and 3 ## be 1 "],
["functions-and-pointers.html", "Module 4 Functions and pointers 4.1 Function declaration 4.2 Functions parameters 4.3 Return values 4.4 Error handling 4.5 Variadic functions 4.6 Iteration and recursion 4.7 Anonymous functions 4.8 Panic 4.9 Pointers 4.10 Functions and pointers Module project", " Module 4 Functions and pointers 4.1 Function declaration 4.2 Functions parameters 4.3 Return values 4.4 Error handling 4.5 Variadic functions 4.6 Iteration and recursion 4.7 Anonymous functions 4.8 Panic 4.9 Pointers 4.10 Functions and pointers Module project package main import &quot;fmt&quot; // fibonacci returns the nth Fibonacci number. func fibonacci(n int) int { if n &lt; 2 { return n } return fibonacci(n-1) + fibonacci(n-2) } // fibonacciSequence changes the int slice to make it contain the Fibonacci // numbers according to its keys. This function operates on the actual slice, // that&#39;s why it does not return anything. func fibonacciSequence(slice []int) { for n := range slice { slice[n] = fibonacci(n) } } func main() { // Create an empty int slice of length 10 sequence := make([]int, 10) // Fill the slice with Fibonacci numbers secuence fibonacciSequence(sequence) fmt.Println(sequence) } ## [0 1 1 2 3 5 8 13 21 34] "],
["methods.html", "Module 5 Methods 5.1 Method declarations 5.2 Methods with a pointer receiver 5.3 Composing types with structs 5.4 Working with struct methods 5.5 Method values 5.6 Method expressions 5.7 Encapsulation", " Module 5 Methods 5.1 Method declarations 5.2 Methods with a pointer receiver 5.3 Composing types with structs 5.4 Working with struct methods 5.5 Method values 5.6 Method expressions 5.7 Encapsulation "],
["interfaces.html", "Module 6 Interfaces 6.1 Introduction 6.2 Interface types 6.3 Satisfaction 6.4 flag.Value 6.5 Interface values 6.6 Sorting with sort.Interface 6.7 The error interface 6.8 Type assertions 6.9 Type switches", " Module 6 Interfaces 6.1 Introduction 6.2 Interface types 6.3 Satisfaction 6.4 flag.Value 6.5 Interface values 6.6 Sorting with sort.Interface 6.7 The error interface 6.8 Type assertions 6.9 Type switches "],
["goroutines-and-channels.html", "Module 7 Goroutines and channels 7.1 What is goroutine 7.2 Introduction to concurrency 7.3 Channels 7.4 Types of channels 7.5 Pipelines 7.6 Looping in parallel 7.7 time.Tick 7.8 The select statement 7.9 Cancellation Module project", " Module 7 Goroutines and channels 7.1 What is goroutine 7.2 Introduction to concurrency 7.3 Channels 7.4 Types of channels 7.5 Pipelines 7.6 Looping in parallel 7.7 time.Tick 7.8 The select statement 7.9 Cancellation Module project package main import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot; ) const ( NumberOfRacers = 10 NumberOfLaps = 3 MaxSleepDuration = 3 // seconds ) func init() { rand.Seed(time.Now().UnixNano()) } func race(racer int, start chan struct{}, finish chan int, status chan []int, wg *sync.WaitGroup) { defer wg.Done() &lt;-start for lap := 1; lap &lt;= NumberOfLaps; lap++ { sleep := time.Duration(rand.Intn(MaxSleepDuration)) time.Sleep(sleep * time.Second) go func(racer, lap int) { status &lt;- []int{racer, lap} }(racer, lap) } finish &lt;- racer } func main() { start := make(chan struct{}) finish := make(chan int) status := make(chan []int) done := make(chan struct{}) var wg sync.WaitGroup wg.Add(NumberOfRacers) for racer := 1; racer &lt;= NumberOfRacers; racer++ { go race(racer, start, finish, status, &amp;wg) } go func() { wg.Wait() close(done) }() startTime := time.Now() close(start) ticker := time.NewTicker(time.Second) defer ticker.Stop() var winners []int OuterLoop: for { select { case t := &lt;-ticker.C: fmt.Println(&quot;Race time:&quot;, t.Sub(startTime)) case s := &lt;-status: fmt.Printf(&quot;Racer #%d is on lap %d\\n&quot;, s[0], s[1]) case finished := &lt;-finish: fmt.Printf(&quot;Racer #%d finished!\\n&quot;, finished) if len(winners) &lt; 3 { winners = append(winners, finished) } case &lt;-done: break OuterLoop } } close(finish) close(status) fmt.Println(&quot;\\nWinners:&quot;) place := 1 for _, racer := range winners { fmt.Printf(&quot;%d place: Racer #%d\\n&quot;, place, racer) place++ } } ## Racer #2 is on lap 2 ## Racer #10 is on lap 1 ## Racer #6 is on lap 1 ## Racer #1 is on lap 1 ## Racer #2 is on lap 1 ## Racer #4 is on lap 2 ## Racer #4 is on lap 1 ## Race time: 1.000140058s ## Racer #5 is on lap 1 ## Racer #3 is on lap 2 ## Racer #7 finished! ## Racer #8 is on lap 1 ## Racer #10 is on lap 2 ## Racer #3 is on lap 1 ## Racer #7 is on lap 1 ## Racer #7 is on lap 2 ## Racer #7 is on lap 3 ## Race time: 2.000289239s ## Racer #3 is on lap 3 ## Racer #3 finished! ## Racer #2 finished! ## Racer #9 is on lap 2 ## Racer #6 is on lap 2 ## Racer #1 is on lap 2 ## Racer #4 finished! ## Racer #5 is on lap 2 ## Racer #2 is on lap 3 ## Racer #9 is on lap 1 ## Racer #4 is on lap 3 ## Racer #10 finished! ## Racer #10 is on lap 3 ## Race time: 3.000141363s ## Racer #1 finished! ## Racer #9 finished! ## Racer #6 finished! ## Racer #8 is on lap 2 ## Racer #9 is on lap 3 ## Racer #6 is on lap 3 ## Racer #1 is on lap 3 ## Race time: 4.000170603s ## Racer #5 finished! ## Racer #5 is on lap 3 ## Race time: 5.000135797s ## Racer #8 finished! ## ## Winners: ## 1 place: Racer #7 ## 2 place: Racer #3 ## 3 place: Racer #2 "]
]
