\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Go course},
            pdfauthor={Petr Shevtsov},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\providecommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{Go course}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Petr Shevtsov}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
      \predate{\centering\large\emph}
  \postdate{\par}
    \date{2019-06-19}

\renewcommand{\chaptername}{Module}

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\newenvironment{rmdblock}[1]
  {
  \begin{itemize}
  \renewcommand{\labelitemi}{
    \raisebox{-.7\height}[0pt][0pt]{
      {\setkeys{Gin}{width=3em,keepaspectratio}}
    }
  }
  \setlength{\fboxsep}{1em}
  \begin{kframe}
  \item
  }
  {
  \end{kframe}
  \end{itemize}
  }
\newenvironment{rmdnote}
  {\begin{rmdblock}{note}}
  {\end{rmdblock}}

\let\BeginKnitrBlock\begin \let\EndKnitrBlock\end
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

The course is targeted at a beginner level student new to Go but might be
familiar with 1-2 other languages (e.g.~Python, HTML).

\hypertarget{basic-concepts}{%
\chapter{Basic concepts}\label{basic-concepts}}

\hypertarget{what-is-go}{%
\section{What is Go?}\label{what-is-go}}

\hypertarget{welcome-to-go}{%
\subsection{Welcome to Go}\label{welcome-to-go}}

Go is a general purpose programming language.

It was designed as a ``C for the 21st century'' with scalability and concurrency
in mind. It belongs to the C-family, like C++, Java and C\#. It also has
characteristics of a dynamic language, so Ruby or Python programmers would also
find it comfortable to work with.

Go is used to create computer programs. Anything from graphics and mobile
application to machine learning and networked servers can be written in Go.

The following notable software pieces are written (or have some parts) written
in Go:

\begin{itemize}
\tightlist
\item
  Docker
\item
  Kubernetes
\item
  Dropbox
\item
  OpenShift
\item
  YouTube
\item
  Google Chrome
\end{itemize}

Go is a compiled, statically typed language with garbage collection.

What does it mean?

\hypertarget{compilation}{%
\subsubsection*{Compilation}\label{compilation}}
\addcontentsline{toc}{subsubsection}{Compilation}

During the compilation the source code you wrote is translated into the
low-level language natural to the computer to execute. Compiled languages are
tend to \textbf{run faster} because they operate closer to the ``bare metal'', but
sometimes it is unpleasant to work with compiled languages because the
compilation can be slow. Compilation speed is on of the Go's benefits, it was
designed to be \textbf{quick to compile}.

\hypertarget{static-typing}{%
\subsubsection*{Static typing}\label{static-typing}}
\addcontentsline{toc}{subsubsection}{Static typing}

Being statically typed means that variables \textbf{must be of a specific type}
(text string, number, boolean, list, etc). Using a type system, the compiler is
able to \textbf{detect problems} earlier, before the program is actually used.

\hypertarget{garbage-collection}{%
\subsubsection*{Garbage collection}\label{garbage-collection}}
\addcontentsline{toc}{subsubsection}{Garbage collection}

Languages with garbage collectors are able to keep track of variables and free
them when they \textbf{are no longer used}.

\hypertarget{question}{%
\subsection*{Question}\label{question}}
\addcontentsline{toc}{subsection}{Question}

Go is a:

\begin{itemize}
\tightlist
\item
  Client-side scripting language
\item
  \textbf{General purpose programming language}
\item
  Machine learning program
\end{itemize}

\hypertarget{question-1}{%
\subsection*{Question}\label{question-1}}
\addcontentsline{toc}{subsection}{Question}

Which of the following is true?

\begin{itemize}
\tightlist
\item
  Go is an interpreted language
\item
  \textbf{Go has garbage collection}
\item
  Go is a dynamically typed language
\item
  Go compiles into a virtual machine byte code
\end{itemize}

\hypertarget{hello-world}{%
\section{Hello, world!}\label{hello-world}}

\hypertarget{your-first-go-program}{%
\subsection{Your first Go program}\label{your-first-go-program}}

A ``Hello, world!'' program is traditionally used to introduce programmers to a
programming language. Below is a Go code that outputs ``Hello, world!'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(}\StringTok{"Hello, world!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Hello, world!
\end{verbatim}

Let's break down the code to understand each line:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

Every Go file belongs to one (and only one) \emph{package}. The package to which the
code file belongs must be indicated before any other code lines. A standalone
executable belongs to package \texttt{main}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \StringTok{"fmt"}
\end{Highlighting}
\end{Shaded}

This line tells Go that this program needs some elements (in out case the
function \texttt{Println}) from the package \texttt{fmt}, which implements formatted I/O
analogous to \texttt{printf} and \texttt{scanf} in C. The package names are enclosed within
double quotes (\texttt{""}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{function main() \{ \}}
\end{Highlighting}
\end{Shaded}

When the program executes, the first function called will be \texttt{main()} (like in
C). The code in functions (or the body) is enclosed between braces: \texttt{\{\ \}}

\BeginKnitrBlock{rmdnote}
The first \texttt{\{} must be on the same line as the function declaration!
\EndKnitrBlock{rmdnote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    fmt.Println(}\StringTok{"Hello, world!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This line calls the function \texttt{Println} from the package \texttt{fmt}, which prints the
string parameter to the console, followed by a newline character \texttt{\textbackslash{}n}.

\BeginKnitrBlock{rmdnote}
The same result can be obtained with \texttt{fmt.Print("Hello,\ world!\textbackslash{}n")}
\EndKnitrBlock{rmdnote}

\hypertarget{question-2}{%
\subsection*{Question}\label{question-2}}
\addcontentsline{toc}{subsection}{Question}

Fill in the blanks to import the \texttt{fmt} package:

\texttt{import\ "}\textbf{\texttt{fmt}}\texttt{"}

\hypertarget{question-3}{%
\subsection*{Question}\label{question-3}}
\addcontentsline{toc}{subsection}{Question}

What is the starting point for a computer program written in Go?

\begin{itemize}
\tightlist
\item
  \textbf{Main function}
\item
  Fist line
\item
  \texttt{package\ main}
\end{itemize}

\hypertarget{question-4}{%
\subsection*{Question}\label{question-4}}
\addcontentsline{toc}{subsection}{Question}

Rearrange the code blocks to form a valid Go program:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(}\StringTok{"Go is awesome!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-go-cli}{%
\section{The Go CLI}\label{the-go-cli}}

\hypertarget{getting-the-tools}{%
\subsection{Getting the tools}\label{getting-the-tools}}

TODO:

\href{https://golang.org/doc/install}{Installation instructions}

\hypertarget{value-types}{%
\section{Value types}\label{value-types}}

\hypertarget{boolean-type}{%
\subsection{Boolean type}\label{boolean-type}}

A boolean type contains either \texttt{true} or \texttt{false}. The boolean type is \texttt{bool}

\BeginKnitrBlock{rmdnote}
\textbf{Conditional expressions} are an example of Boolean type.
\EndKnitrBlock{rmdnote}

\hypertarget{question-5}{%
\subsubsection*{Question}\label{question-5}}
\addcontentsline{toc}{subsubsection}{Question}

What is the result of \texttt{42\ ==\ 42} operation? Is it true or false?

\textbf{true}

\hypertarget{numeric-types}{%
\subsection{Numeric types}\label{numeric-types}}

Go has the well known types such as \texttt{int}. The length of this type depends on
the machine, so on 32-bit machine it is 32 bits while on 64-bit machine it is
64 bits. \texttt{uint} type is like \texttt{int} but it stores unsigned values. This type
also has the appropriate length for the machine.

However, If you want to be explicit about the length you can use either \texttt{int32}
or \texttt{uint32}.

The full list of integers (signed and unsigned) is the following: \texttt{int8},
\texttt{int16}, \texttt{int64}, \texttt{byte}, \texttt{uint8}, \texttt{uint16}, \texttt{uint32} and \texttt{uint64}.

\BeginKnitrBlock{rmdnote}
\texttt{byte} is an alias for \texttt{uint8}.
\EndKnitrBlock{rmdnote}

For floating point values there is \texttt{float32} and \texttt{float64}. There is \emph{no}
machine dependent \texttt{float} type.

\BeginKnitrBlock{rmdnote}
A 64 bit integer or floating point value is \emph{always} 64 bit, even on 32-bit
architectures.
\EndKnitrBlock{rmdnote}

\hypertarget{question-6}{%
\subsubsection*{Question}\label{question-6}}
\addcontentsline{toc}{subsubsection}{Question}

Which of the following are correct values for numeric types? Select all that
apply

\begin{itemize}
\tightlist
\item
  \textbf{1000}
\item
  true
\item
  \textbf{3.14}
\item
  ``hello''
\end{itemize}

\hypertarget{question-7}{%
\subsubsection*{Question}\label{question-7}}
\addcontentsline{toc}{subsubsection}{Question}

Is 3.14 an integer?

\begin{itemize}
\tightlist
\item
  Yes
\item
  \textbf{No}
\end{itemize}

\hypertarget{strings}{%
\subsection{Strings}\label{strings}}

Another important built-in type is \texttt{string}. \texttt{"a"}, \texttt{"Hello\ world"} or
\texttt{"Καλημέρα\ κόσμε"} are \texttt{string} values.

\hypertarget{runes}{%
\subsection{Runes}\label{runes}}

\texttt{rune} is an alias for \texttt{int32}. It is an UTF-8 encoded code point. The purpose
of \texttt{rune} is similar to the \texttt{char} type in C++ but \texttt{rune} in Go may contain a
Unicode character while \texttt{char} in C++ contains an ASCII symbol.

\hypertarget{complex-numbers}{%
\subsection{Complex numbers}\label{complex-numbers}}

Go has native support for complex numbers. Complex numbers types are
\texttt{complex64} and \texttt{complex128}.

\hypertarget{question-8}{%
\subsection*{Question}\label{question-8}}
\addcontentsline{toc}{subsection}{Question}

Which of the following are the valid value types in Go? Select all that apply.

\begin{itemize}
\tightlist
\item
  boolean
\item
  \textbf{int}
\item
  float
\item
  integer32
\item
  \textbf{float64}
\end{itemize}

\hypertarget{variables}{%
\section{Variables}\label{variables}}

\hypertarget{variable-names}{%
\subsection{Variable names}\label{variable-names}}

A variable is a name for an area in memory. Creating a variable reserves a
memory location, or a space in memory for storing values.

The name of a variable (also called the identifier) in Go is a sequence of
letters, digits and underscore character. The first character in a variable
name must be a letter or an underscore.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\NormalTok{_z5}
\end{Highlighting}
\end{Shaded}

Letters in Go variable names are not limited to the letters of the Latin
alphabet, so the following variable names are also valid:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{αβ}
\NormalTok{åβč}
\end{Highlighting}
\end{Shaded}

The naming of identifiers for variables follows the \texttt{camelCase} rules (start
with a small letter, every new part of the word starts with a capital letter):
\texttt{startDate}, \texttt{wordCount}.

\hypertarget{question-9}{%
\subsubsection*{Question}\label{question-9}}
\addcontentsline{toc}{subsubsection}{Question}

Which of the following are valid Go variable names? Select all that apply.

\begin{itemize}
\tightlist
\item
  case
\item
  a+b
\item
  \textbf{x}
\item
  1a
\item
  \textbf{sum}
\end{itemize}

\hypertarget{declaration-and-assignment}{%
\subsection{Declaration and assignment}\label{declaration-and-assignment}}

Variables can be declared using the \texttt{var} keyword. Go is different from other
languages (e.g.~C or C++) in that the type of a variable is specified \emph{after}
the variable name.

In C:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a;}
\end{Highlighting}
\end{Shaded}

In Go:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ a }\DataTypeTok{int}
\end{Highlighting}
\end{Shaded}

\BeginKnitrBlock{rmdnote}
Multiple variables of the same type can be also declared on a single line:
\texttt{var\ x,\ y\ int}.
\EndKnitrBlock{rmdnote}

Multiple \texttt{var} declarations may also be grouped:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ (}
\NormalTok{    n }\DataTypeTok{int}
\NormalTok{    s }\DataTypeTok{string}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When a variable is declared it contains the default zero or null value for its
type: \texttt{0} for \texttt{int}, \texttt{false} for \texttt{bool}, empty string (\texttt{""}) for \texttt{string}, etc.

Declaring and assigning variables in Go is a two step process, but they may be
combined. The following two pieces of code have the same effect:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ a }\DataTypeTok{int}
\KeywordTok{var}\NormalTok{ b }\DataTypeTok{bool}
\NormalTok{a = }\DecValTok{42}
\NormalTok{b = }\OtherTok{true}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ a }\DataTypeTok{int}\NormalTok{ = }\DecValTok{42}
\KeywordTok{var}\NormalTok{ b }\DataTypeTok{bool}\NormalTok{ = }\OtherTok{true}
\end{Highlighting}
\end{Shaded}

Go can infer the type of the declared and assigned variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ a = }\DecValTok{42}   \CommentTok{// inferred type: int}
\KeywordTok{var}\NormalTok{ b = }\OtherTok{true} \CommentTok{// inferred type: bool}
\end{Highlighting}
\end{Shaded}

\hypertarget{short-declaration-syntax}{%
\subsection{Short declaration syntax}\label{short-declaration-syntax}}

With the type omitted, the keyword \texttt{var} is pretty superfluous, so we may write
as the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a := }\DecValTok{42}
\NormalTok{b := }\OtherTok{true}
\end{Highlighting}
\end{Shaded}

\BeginKnitrBlock{rmdnote}
The types of \texttt{a} and \texttt{b} (\texttt{int} and \texttt{bool}) are inferred by the compiler.
\EndKnitrBlock{rmdnote}

You can also make use of parallel assignment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a, b := }\DecValTok{42}\NormalTok{, }\OtherTok{true}
\end{Highlighting}
\end{Shaded}

\hypertarget{question-10}{%
\subsubsection*{Question}\label{question-10}}
\addcontentsline{toc}{subsubsection}{Question}

What is the type of \texttt{b} in the following assignment?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ a }\DataTypeTok{int}
\NormalTok{b := a}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{int}
\item
  pointer
\item
  interface\{\}
\end{itemize}

\hypertarget{discard-assignments}{%
\subsection{Discard assignments}\label{discard-assignments}}

A special name for a variable is \texttt{\_} (underscore). Any value assigned to it is
discarded:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// we only assign the integer value of 36 to b and discard the value 25.}
\NormalTok{_, b := }\DecValTok{25}\NormalTok{, }\DecValTok{36}
\end{Highlighting}
\end{Shaded}

\BeginKnitrBlock{rmdnote}
In later sections you'll learn that Go supports \textbf{multiple return values} from
functions. Discard addignments are useful if some of the returned values aren't
needed, so such values can be \emph{discarded}
\EndKnitrBlock{rmdnote}

\hypertarget{declaration-and-usage}{%
\subsection{Declaration and usage}\label{declaration-and-usage}}

A variable which is used, but not declared, gives a compiler error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
undefined: a
\end{verbatim}

Declared but otherwise unused variables are a compiler error in Go:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{func}\NormalTok{ main() \{}
    \KeywordTok{var}\NormalTok{ x }\DataTypeTok{int}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
x declared and not used
\end{verbatim}

\hypertarget{operators}{%
\section{Operators}\label{operators}}

Values are combined together with \textbf{operators} into \textbf{expressions}. Every
value type has its own defined set of operators, which can work with values of
that type.

\BeginKnitrBlock{rmdnote}
Using an operator for a value type for which it is not defined leads to a
compiler error.
\EndKnitrBlock{rmdnote}

\hypertarget{arithmetic-operators}{%
\subsection{Arithmetic operators}\label{arithmetic-operators}}

The common arithmetic operators exist for both integers and floats:

\begin{itemize}
\tightlist
\item
  \texttt{+} (addition)
\item
  \texttt{-} (subtraction)
\item
  \texttt{*} (multiplication)
\item
  \texttt{/} (division)
\end{itemize}

\texttt{/} for integers is integer division. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(}\DecValTok{9}\NormalTok{ / }\DecValTok{4}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2
\end{verbatim}

The modulus operator \texttt{\%} is only defined for integers:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(}\DecValTok{9}\NormalTok{ % }\DecValTok{4}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

There are shortcuts for these operations: \texttt{a\ =\ a\ +\ b} can be shortened to \texttt{a\ +=\ b}, and the same goes for \texttt{-=}, \texttt{*=}, \texttt{/=} and \texttt{\%=}.

\hypertarget{question-11}{%
\subsubsection*{Question}\label{question-11}}
\addcontentsline{toc}{subsubsection}{Question}

What is the value of the \texttt{result} variable?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a := }\DecValTok{12}
\NormalTok{b := }\DecValTok{5}
\NormalTok{result := a % b}
\end{Highlighting}
\end{Shaded}

\textbf{2}

\hypertarget{operator-precedence}{%
\subsection{Operator precedence}\label{operator-precedence}}

Some operators have higher priority (precedence) than others. Operators of the
same precedence are performed from left to right.

\texttt{*}, \texttt{/} and \texttt{\%} operators have higher precedence, while \texttt{+}, \texttt{-} operators
have lower precedence.

It is allowed to clarify expressions by using \texttt{(\ )} to indicate priority in
operations.

\BeginKnitrBlock{rmdnote}
Expressions contained in \texttt{(\ )} are always computed first.
\EndKnitrBlock{rmdnote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    a := }\DecValTok{9}
\NormalTok{    b := }\DecValTok{6}
\NormalTok{    c := }\DecValTok{3}

\NormalTok{    fmt.Println(a - b + c)}
\NormalTok{    fmt.Println(a + b / c)}
\NormalTok{    fmt.Println((a + b) / c)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 6
## 11
## 5
\end{verbatim}

\hypertarget{question-12}{%
\subsubsection*{Question}\label{question-12}}
\addcontentsline{toc}{subsubsection}{Question}

Fill in the blanks to subtract \texttt{b} from \texttt{a} and add \texttt{c} to the result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a := }\DecValTok{9}
\NormalTok{b := }\DecValTok{6}
\NormalTok{c := }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\texttt{result\ :=\ a}\textbf{\texttt{-}}\texttt{b}\textbf{\texttt{+}}\texttt{c}

\hypertarget{increment-and-decrement}{%
\subsection{Increment and decrement}\label{increment-and-decrement}}

For integers and floats Go has \texttt{++} (increment) and \texttt{-\/-} (decrement) operators:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i++ }\CommentTok{// is short for i += 1 is short for i = i + 1}
\NormalTok{i-- }\CommentTok{// is short for i -= 1 is short for i = i - 1}
\end{Highlighting}
\end{Shaded}

The increment and decrement operators can only be used after the number
(postfix).

\texttt{++} and \texttt{-\/-} may only be used as statements, not expressions. While \texttt{n\ =\ i++}
is accepted in C, C++ and Java, it is invalid in Go.

\hypertarget{question-13}{%
\subsubsection*{Question}\label{question-13}}
\addcontentsline{toc}{subsubsection}{Question}

Which of the following are correct use of increment and decrement operators in
Go? Select all that apply:

\begin{itemize}
\tightlist
\item
  x = y++
\item
  \textbf{j++}
\item
  --n
\item
  f(i++)
\item
  \textbf{i--}
\end{itemize}

\hypertarget{constants}{%
\section{Constants}\label{constants}}

Constants in Go are created at compile time. Constants can only be numbers,
strings or booleans.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{const}\NormalTok{ a = }\DecValTok{42}

\CommentTok{// Constants can be groupped together}
\KeywordTok{const}\NormalTok{ (}
\NormalTok{    b = }\OtherTok{true}
\NormalTok{    c = }\StringTok{"Hello world"}
\NormalTok{    pi = }\DecValTok{3}\FloatTok{.14}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{    fmt.Println(b)}
\NormalTok{    fmt.Println(c)}
\NormalTok{    fmt.Println(pi)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 42
## true
## Hello world
## 3.14
\end{verbatim}

\hypertarget{question-14}{%
\subsubsection*{Question}\label{question-14}}
\addcontentsline{toc}{subsubsection}{Question}

Fill in the blanks to define a constant \texttt{x} which equals to \texttt{42}:

\textbf{\texttt{const}} \texttt{x\ =\ 42}

\hypertarget{iota-enumerator}{%
\subsection{\texorpdfstring{\texttt{iota} enumerator}{iota enumerator}}\label{iota-enumerator}}

You can use \texttt{iota} to enumerate constant values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    a = }\OtherTok{iota} \CommentTok{// 0}
\NormalTok{    b = }\OtherTok{iota} \CommentTok{// 1}
\NormalTok{    c = }\OtherTok{iota} \CommentTok{// 2}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{    fmt.Println(b)}
\NormalTok{    fmt.Println(c)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0
## 1
## 2
\end{verbatim}

The first use of \texttt{iota} will yield 0, so \texttt{a} is equal to 0, whenever \texttt{iota} is
used again on a new line its value is incremented with 1, so \texttt{b} has a value of
1 and \texttt{c} has the value of 2.

This can be shortened to:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    a = }\OtherTok{iota} \CommentTok{// 0}
\NormalTok{    b        }\CommentTok{// 1}
\NormalTok{    c        }\CommentTok{// 2}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{    fmt.Println(b)}
\NormalTok{    fmt.Println(c)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 0
## 1
## 2
\end{verbatim}

\texttt{iota} can also be used in expressions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    a = }\OtherTok{iota}\NormalTok{ + }\DecValTok{10} \CommentTok{// 10}
\NormalTok{    b             }\CommentTok{// 11}
\NormalTok{    c             }\CommentTok{// 12}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{    fmt.Println(b)}
\NormalTok{    fmt.Println(c)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 10
## 11
## 12
\end{verbatim}

A new \texttt{const} block initializes \texttt{iota} back to 0:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    a = }\OtherTok{iota}\NormalTok{ + }\DecValTok{10} \CommentTok{// 10}
\NormalTok{    b             }\CommentTok{// 11}
\NormalTok{    c             }\CommentTok{// 12}
\NormalTok{)}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    _ = }\OtherTok{iota}      \CommentTok{// ignore first value by assigning to blank identifier}
\NormalTok{    x = }\OtherTok{iota}\NormalTok{ * }\DecValTok{10} \CommentTok{// 10}
\NormalTok{    y             }\CommentTok{// 20}
\NormalTok{    z             }\CommentTok{// 30}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    fmt.Println(a)}
\NormalTok{    fmt.Println(b)}
\NormalTok{    fmt.Println(c)}

\NormalTok{    fmt.Println(x)}
\NormalTok{    fmt.Println(y)}
\NormalTok{    fmt.Println(z)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 10
## 11
## 12
## 10
## 20
## 30
\end{verbatim}

\hypertarget{question-15}{%
\subsubsection*{Question}\label{question-15}}
\addcontentsline{toc}{subsubsection}{Question}

What is the value of the constant \texttt{z}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ a = }\OtherTok{iota}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    _ = }\OtherTok{iota}
\NormalTok{    x = }\OtherTok{iota}\NormalTok{ * }\DecValTok{10}\NormalTok{ - }\DecValTok{3}
\NormalTok{    y}
\NormalTok{    z = }\OtherTok{iota}\NormalTok{ + }\DecValTok{42}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{45}

\hypertarget{comments}{%
\section{Comments}\label{comments}}

Comments are explanatory information that you can include in the Go code to
explain what the code is doing. The compiler ignores comments, so they have no
affect on a program.

Go uses C++-style comments: \texttt{//} for single-line comments that finish at the
end of the line and \texttt{/*~\ldots{}~*/} for comments than can span multiple lines.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
    \CommentTok{// Output a string "Hello, world!"}
\NormalTok{    fmt.Println(}\StringTok{"Hello, world!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Hello, world!
\end{verbatim}

\BeginKnitrBlock{rmdnote}
Comments clarify the program's intent to the reader. Later on you'll learn
how to use comments to produce documentation for the Go code.
\EndKnitrBlock{rmdnote}

\hypertarget{question-16}{%
\subsection*{Question}\label{question-16}}
\addcontentsline{toc}{subsection}{Question}

Which of the following indicates a single-line comment?

\begin{itemize}
\tightlist
\item
  \texttt{-\/-\ single-line\ comment}
\item
  \textbf{\texttt{//\ single-line\ comment}}
\item
  \texttt{\#\ single-line\ comment}
\end{itemize}

\hypertarget{packages-and-imports}{%
\section{Packages and imports}\label{packages-and-imports}}

TODO:

\hypertarget{try-it-yourself}{%
\section*{Try it yourself}\label{try-it-yourself}}
\addcontentsline{toc}{section}{Try it yourself}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// This is a comment.}
\CommentTok{// Every Go file must be a part of some package.}
\CommentTok{// This file is a part of package main.}
\KeywordTok{package}\NormalTok{ main}

\CommentTok{// We import package "fmt" from the standard Go library.}
\KeywordTok{import} \StringTok{"fmt"}

\CommentTok{// `who` is a constant.}
\KeywordTok{const}\NormalTok{ who = }\StringTok{"world"}

\CommentTok{// Function main() is the main entry point of any application written in Go.}
\KeywordTok{func}\NormalTok{ main() \{}
    \CommentTok{// We declare `greeting` as a variable of type string and assign the value.}
    \KeywordTok{var}\NormalTok{ greeting }\DataTypeTok{string}\NormalTok{ = }\StringTok{"Hello"}
    \CommentTok{// We declare `message` variable using the shorthand syntax. The type of}
    \CommentTok{// the variable is determined by the assigned value. In our case it is}
    \CommentTok{// string type.}
\NormalTok{    message := greeting + }\StringTok{", "}\NormalTok{ + who}
    \CommentTok{// Let's print the value of the variable `message` using the function from}
    \CommentTok{// the package "fmt".}
\NormalTok{    fmt.Println(message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Hello, world
\end{verbatim}

\hypertarget{conditionals-and-loops}{%
\chapter{Conditionals and Loops}\label{conditionals-and-loops}}

\hypertarget{the-if-statement}{%
\section{\texorpdfstring{The \texttt{if} statement}{The if statement}}\label{the-if-statement}}

\hypertarget{the-else-statement}{%
\section{\texorpdfstring{The \texttt{else} statement}{The else statement}}\label{the-else-statement}}

\hypertarget{ifelse-chains}{%
\section{\texorpdfstring{\texttt{if}/\texttt{else} chains}{if/else chains}}\label{ifelse-chains}}

\hypertarget{the-if-statement-with-expression}{%
\section{\texorpdfstring{The \texttt{if} statement with expression}{The if statement with expression}}\label{the-if-statement-with-expression}}

\hypertarget{the-switch-statement}{%
\section{\texorpdfstring{The \texttt{switch} statement}{The switch statement}}\label{the-switch-statement}}

\hypertarget{the-switch-without-condition}{%
\section{\texorpdfstring{The \texttt{switch} without condition}{The switch without condition}}\label{the-switch-without-condition}}

\hypertarget{the-for-statement}{%
\section{\texorpdfstring{The \texttt{for} statement}{The for statement}}\label{the-for-statement}}

\hypertarget{the-defer-statement}{%
\section{\texorpdfstring{The \texttt{defer} statement}{The defer statement}}\label{the-defer-statement}}

\hypertarget{module-project}{%
\section*{Module project}\label{module-project}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main() \{}
    \CommentTok{// Here we loop from 0 to 99 and only output some sentences for particular}
    \CommentTok{// cases.}
    \KeywordTok{for}\NormalTok{ age := }\DecValTok{0}\NormalTok{; age < }\DecValTok{99}\NormalTok{; age++ \{}
        \KeywordTok{switch}\NormalTok{ age \{}
        \KeywordTok{case} \DecValTok{16}\NormalTok{:}
\NormalTok{            fmt.Println(}\StringTok{"When you're"}\NormalTok{, age, }\StringTok{"you can drive a car!"}\NormalTok{)}
        \KeywordTok{case} \DecValTok{18}\NormalTok{:}
\NormalTok{            fmt.Println(}\StringTok{"When you're"}\NormalTok{, age, }\StringTok{"you can buy a lottery ticket!"}\NormalTok{)}
        \KeywordTok{case} \DecValTok{21}\NormalTok{:}
\NormalTok{            fmt.Println(}\StringTok{"When you're"}\NormalTok{, age, }\StringTok{"you can buy some beer!"}\NormalTok{)}
            \KeywordTok{break}
        \KeywordTok{default}\NormalTok{:}
            \KeywordTok{continue}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## When you're 16 you can drive a car!
## When you're 18 you can buy a lottery ticket!
## When you're 21 you can buy some beer!
\end{verbatim}

\hypertarget{composite-data-types}{%
\chapter{Composite Data Types}\label{composite-data-types}}

\hypertarget{arrays}{%
\section{Arrays}\label{arrays}}

\hypertarget{loops-and-arrays}{%
\section{Loops and arrays}\label{loops-and-arrays}}

\hypertarget{slices}{%
\section{Slices}\label{slices}}

\hypertarget{appending-items-to-slices}{%
\section{Appending items to slices}\label{appending-items-to-slices}}

\hypertarget{range}{%
\section{Range}\label{range}}

\hypertarget{maps}{%
\section{Maps}\label{maps}}

\hypertarget{arrays-vs-maps}{%
\section{Arrays vs maps}\label{arrays-vs-maps}}

\hypertarget{structs}{%
\section{Structs}\label{structs}}

\hypertarget{struct-literals}{%
\section{Struct literals}\label{struct-literals}}

\hypertarget{operations-with-structs}{%
\section{Operations with structs}\label{operations-with-structs}}

\hypertarget{module-project-1}{%
\section*{Module project}\label{module-project-1}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import}\NormalTok{ (}
    \StringTok{"fmt"}
    \StringTok{"strings"}
\NormalTok{)}

\CommentTok{// Shakespeare contains the text of one of the Shakespeare's sonets. We'll use}
\CommentTok{// this text to count words in it.}
\KeywordTok{const}\NormalTok{ Shakespeare = }\StringTok{`}
\StringTok{From fairest creatures we desire increase,}
\StringTok{That thereby beauty's rose might never die,}
\StringTok{But as the riper should by time decease,}
\StringTok{His tender heir might bear his memory:}
\StringTok{But thou contracted to thine own bright eyes,}
\StringTok{Feed'st thy light's flame with self-substantial fuel,}
\StringTok{Making a famine where abundance lies,}
\StringTok{Thy self thy foe, to thy sweet self too cruel:}
\StringTok{Thou that art now the world's fresh ornament,}
\StringTok{And only herald to the gaudy spring,}
\StringTok{Within thine own bud buriest thy content,}
\StringTok{And tender churl mak'st waste in niggarding:}
\StringTok{  Pity the world, or else this glutton be,}
\StringTok{  To eat the world's due, by the grave and thee.}
\StringTok{`}

\CommentTok{// getWord returns a word in lower case and with trimmed punctuation.}
\KeywordTok{func}\NormalTok{ getWord(s }\DataTypeTok{string}\NormalTok{) }\DataTypeTok{string}\NormalTok{ \{}
    \KeywordTok{return}\NormalTok{ strings.ToLower(strings.Trim(s, }\StringTok{",:."}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    wordCount := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{map}\NormalTok{[}\DataTypeTok{string}\NormalTok{]}\DataTypeTok{int}\NormalTok{)}
    \CommentTok{// Here we loop through the slice of words produced using strings.Fields}
    \CommentTok{// function. That function splits text into a slice of strings using}
    \CommentTok{// space-characters: whitespaces, tabs, new line symbols, etc.}
    \KeywordTok{for}\NormalTok{ _, word := }\KeywordTok{range}\NormalTok{ strings.Fields(Shakespeare) \{}
        \CommentTok{// Trim punctuation and make it lower case.}
\NormalTok{        word = getWord(word)}
        \CommentTok{// Increase the count. If the there was no such word in the map it uses}
        \CommentTok{// zero as its count.}
\NormalTok{        wordCount[word]++}
\NormalTok{    \}}

    \CommentTok{// Loop through the map and print its keys and values.}
    \KeywordTok{for}\NormalTok{ word, count := }\KeywordTok{range}\NormalTok{ wordCount \{}
\NormalTok{        fmt.Println(word, count)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## but 2
## eyes 1
## where 1
## grave 1
## might 2
## his 2
## memory 1
## self 2
## now 1
## due 1
## as 1
## flame 1
## foe 1
## cruel 1
## herald 1
## beauty's 1
## time 1
## thy 5
## die 1
## bear 1
## sweet 1
## never 1
## tender 2
## ornament 1
## eat 1
## desire 1
## that 2
## riper 1
## bright 1
## gaudy 1
## niggarding 1
## from 1
## fairest 1
## increase 1
## with 1
## world 1
## be 1
## should 1
## own 2
## waste 1
## content 1
## glutton 1
## creatures 1
## rose 1
## decease 1
## thou 2
## fresh 1
## spring 1
## thereby 1
## fuel 1
## famine 1
## art 1
## thee 1
## or 1
## thine 2
## feed'st 1
## light's 1
## self-substantial 1
## a 1
## within 1
## pity 1
## this 1
## heir 1
## making 1
## abundance 1
## bud 1
## buriest 1
## churl 1
## we 1
## the 6
## too 1
## and 3
## by 2
## contracted 1
## lies 1
## world's 2
## only 1
## in 1
## to 4
## mak'st 1
## else 1
\end{verbatim}

\hypertarget{functions-and-pointers}{%
\chapter{Functions and pointers}\label{functions-and-pointers}}

\hypertarget{function-declaration}{%
\section{Function declaration}\label{function-declaration}}

\hypertarget{functions-parameters}{%
\section{Functions parameters}\label{functions-parameters}}

\hypertarget{return-values}{%
\section{Return values}\label{return-values}}

\hypertarget{error-handling}{%
\section{Error handling}\label{error-handling}}

\hypertarget{variadic-functions}{%
\section{Variadic functions}\label{variadic-functions}}

\hypertarget{iteration-and-recursion}{%
\section{Iteration and recursion}\label{iteration-and-recursion}}

\hypertarget{anonymous-functions}{%
\section{Anonymous functions}\label{anonymous-functions}}

\hypertarget{panic}{%
\section{Panic}\label{panic}}

\hypertarget{pointers}{%
\section{Pointers}\label{pointers}}

\hypertarget{functions-and-pointers-1}{%
\section{Functions and pointers}\label{functions-and-pointers-1}}

\hypertarget{module-project-2}{%
\section*{Module project}\label{module-project-2}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \StringTok{"fmt"}

\CommentTok{// fibonacci returns the nth Fibonacci number.}
\KeywordTok{func}\NormalTok{ fibonacci(n }\DataTypeTok{int}\NormalTok{) }\DataTypeTok{int}\NormalTok{ \{}
    \KeywordTok{if}\NormalTok{ n < }\DecValTok{2}\NormalTok{ \{}
        \KeywordTok{return}\NormalTok{ n}
\NormalTok{    \}}
    \KeywordTok{return}\NormalTok{ fibonacci(n}\DecValTok{-1}\NormalTok{) + fibonacci(n}\DecValTok{-2}\NormalTok{)}
\NormalTok{\}}

\CommentTok{// fibonacciSequence changes the int slice to make it contain the Fibonacci}
\CommentTok{// numbers according to its keys. This function operates on the actual slice,}
\CommentTok{// that's why it does not return anything.}
\KeywordTok{func}\NormalTok{ fibonacciSequence(slice []}\DataTypeTok{int}\NormalTok{) \{}
    \KeywordTok{for}\NormalTok{ n := }\KeywordTok{range}\NormalTok{ slice \{}
\NormalTok{        slice[n] = fibonacci(n)}
\NormalTok{    \}}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ main() \{}
    \CommentTok{// Create an empty int slice of length 10}
\NormalTok{    sequence := }\BuiltInTok{make}\NormalTok{([]}\DataTypeTok{int}\NormalTok{, }\DecValTok{10}\NormalTok{)}
    \CommentTok{// Fill the slice with Fibonacci numbers secuence}
\NormalTok{    fibonacciSequence(sequence)}

\NormalTok{    fmt.Println(sequence)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [0 1 1 2 3 5 8 13 21 34]
\end{verbatim}

\hypertarget{methods}{%
\chapter{Methods}\label{methods}}

\hypertarget{method-declarations}{%
\section{Method declarations}\label{method-declarations}}

\hypertarget{methods-with-a-pointer-receiver}{%
\section{Methods with a pointer receiver}\label{methods-with-a-pointer-receiver}}

\hypertarget{composing-types-with-structs}{%
\section{Composing types with structs}\label{composing-types-with-structs}}

\hypertarget{working-with-struct-methods}{%
\section{Working with struct methods}\label{working-with-struct-methods}}

\hypertarget{method-values}{%
\section{Method values}\label{method-values}}

\hypertarget{method-expressions}{%
\section{Method expressions}\label{method-expressions}}

\hypertarget{encapsulation}{%
\section{Encapsulation}\label{encapsulation}}

\hypertarget{module-project-3}{%
\section*{Module project}\label{module-project-3}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import}\NormalTok{ (}
    \StringTok{"fmt"}
\NormalTok{)}

\CommentTok{// printer is a struct with no fields. It only has a method.}
\KeywordTok{type}\NormalTok{ printer }\KeywordTok{struct}\NormalTok{\{\}}

\CommentTok{// receipt is a variadic function. It can be called with any number of}
\CommentTok{// arguments, just like fmt.Println()}
\KeywordTok{func}\NormalTok{ (p printer) receipt(a ...}\KeywordTok{interface}\NormalTok{\{\}) \{}
\NormalTok{    fmt.Println(a...)}
\NormalTok{\}}

\CommentTok{// Account represents a bank account data structure, it has one field and an}
\CommentTok{// embedded struct.}
\KeywordTok{type}\NormalTok{ Account }\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    balance }\DataTypeTok{int}
\NormalTok{    printer}
\NormalTok{\}}

\CommentTok{// NewAccount created a new Account setting the initial balance.}
\KeywordTok{func}\NormalTok{ NewAccount(balance }\DataTypeTok{int}\NormalTok{) *Account \{}
    \KeywordTok{return}\NormalTok{ &Account\{}
\NormalTok{        balance: balance,}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{// Deposit increases the account balance by the specified amount.}
\CommentTok{// It prints the information about the operation using the method of the}
\CommentTok{// embedded printer struct.}
\KeywordTok{func}\NormalTok{ (a *Account) Deposit(amount }\DataTypeTok{int}\NormalTok{) \{}
\NormalTok{    a.receipt(}\StringTok{"--> trying to deposit"}\NormalTok{, amount)}
\NormalTok{    a.balance = a.balance + amount}
\NormalTok{\}}

\CommentTok{// Withdraw checks if the account balance is not lesser than the amount to}
\CommentTok{// withdraw and decreses the balance by the specified amount.}
\CommentTok{// It prints the information about the operation using the method of the}
\CommentTok{// embedded printer struct.}
\KeywordTok{func}\NormalTok{ (a *Account) Withdraw(amount }\DataTypeTok{int}\NormalTok{) \{}
\NormalTok{    a.receipt(}\StringTok{"<-- trying to withdraw"}\NormalTok{, amount)}
    \KeywordTok{if}\NormalTok{ amount > a.balance \{}
\NormalTok{        a.receipt(}\StringTok{"Withdraw error: not enough funds to withdraw"}\NormalTok{, amount)}
        \KeywordTok{return}
\NormalTok{    \}}
\NormalTok{    a.balance = a.balance - amount}
\NormalTok{\}}

\CommentTok{// Balance outputs the account balance using the Method of the embedded printer}
\CommentTok{// struct.}
\KeywordTok{func}\NormalTok{ (a Account) Balance() \{}
\NormalTok{    a.receipt(}\StringTok{"Account balance:"}\NormalTok{, a.balance)}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    account := NewAccount(}\DecValTok{100}\NormalTok{)}
\NormalTok{    account.Balance()}

\NormalTok{    account.Withdraw(}\DecValTok{25}\NormalTok{)}
\NormalTok{    account.Balance()}

\NormalTok{    account.Deposit(}\DecValTok{50}\NormalTok{)}
\NormalTok{    account.Balance()}

\NormalTok{    account.Withdraw(}\DecValTok{1000}\NormalTok{)}
\NormalTok{    account.Balance()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Account balance: 100
## <-- trying to withdraw 25
## Account balance: 75
## --> trying to deposit 50
## Account balance: 125
## <-- trying to withdraw 1000
## Withdraw error: not enough funds to withdraw 1000
## Account balance: 125
\end{verbatim}

\hypertarget{interfaces}{%
\chapter{Interfaces}\label{interfaces}}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

\hypertarget{interface-types}{%
\section{Interface types}\label{interface-types}}

\hypertarget{satisfaction}{%
\section{Satisfaction}\label{satisfaction}}

\hypertarget{flag.value}{%
\section{\texorpdfstring{\texttt{flag.Value}}{flag.Value}}\label{flag.value}}

\hypertarget{interface-values}{%
\section{Interface values}\label{interface-values}}

\hypertarget{sorting-with-sort.interface}{%
\section{\texorpdfstring{Sorting with \texttt{sort.Interface}}{Sorting with sort.Interface}}\label{sorting-with-sort.interface}}

\hypertarget{the-error-interface}{%
\section{\texorpdfstring{The \texttt{error} interface}{The error interface}}\label{the-error-interface}}

\hypertarget{type-assertions}{%
\section{Type assertions}\label{type-assertions}}

\hypertarget{type-switches}{%
\section{Type switches}\label{type-switches}}

\hypertarget{module-project-4}{%
\section*{Module project}\label{module-project-4}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import}\NormalTok{ (}
    \StringTok{"bufio"}
    \StringTok{"fmt"}
    \StringTok{"io"}
    \StringTok{"sort"}
    \StringTok{"strings"}
\NormalTok{)}

\CommentTok{// Shakespeare contains the text of one of the Shakespeare's sonets. We'll use}
\CommentTok{// this text to count words in it.}
\KeywordTok{const}\NormalTok{ Shakespeare = }\StringTok{`}
\StringTok{From fairest creatures we desire increase,}
\StringTok{That thereby beauty's rose might never die,}
\StringTok{But as the riper should by time decease,}
\StringTok{His tender heir might bear his memory:}
\StringTok{But thou contracted to thine own bright eyes,}
\StringTok{Feed'st thy light's flame with self-substantial fuel,}
\StringTok{Making a famine where abundance lies,}
\StringTok{Thy self thy foe, to thy sweet self too cruel:}
\StringTok{Thou that art now the world's fresh ornament,}
\StringTok{And only herald to the gaudy spring,}
\StringTok{Within thine own bud buriest thy content,}
\StringTok{And tender churl mak'st waste in niggarding:}
\StringTok{  Pity the world, or else this glutton be,}
\StringTok{  To eat the world's due, by the grave and thee.}
\StringTok{`}

\CommentTok{// WordCountPair is a record of word and its count.}
\KeywordTok{type}\NormalTok{ WordCountPair }\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    Word  }\DataTypeTok{string}
\NormalTok{    Count }\DataTypeTok{int}
\NormalTok{\}}

\CommentTok{// getWord returns a word in lower case and with trimmed punctuation.}
\KeywordTok{func}\NormalTok{ getWord(s }\DataTypeTok{string}\NormalTok{) }\DataTypeTok{string}\NormalTok{ \{}
    \KeywordTok{return}\NormalTok{ strings.ToLower(strings.Trim(s, }\StringTok{",:."}\NormalTok{))}
\NormalTok{\}}

\CommentTok{// Functions can be types too!}
\KeywordTok{type}\NormalTok{ lessFunc }\KeywordTok{func}\NormalTok{(p1, p2 *WordCountPair) }\DataTypeTok{bool}

\CommentTok{// multiSorter implements the Sort interface, sorting the word-count pairs.}
\KeywordTok{type}\NormalTok{ multiSorter }\KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    wordCountPairs []WordCountPair}
\NormalTok{    less           []lessFunc}
\NormalTok{\}}

\CommentTok{// Sort sorts the argument slice according to the less functions passed to}
\CommentTok{// OrderedBy.}
\KeywordTok{func}\NormalTok{ (ms *multiSorter) Sort(wordCountPairs []WordCountPair) \{}
\NormalTok{    ms.wordCountPairs = wordCountPairs}
\NormalTok{    sort.Sort(ms)}
\NormalTok{\}}

\CommentTok{// OrderedBy returns a Sorter that sorts using the less functions, in order.}
\CommentTok{// Call its Sort method to sort the data.}
\KeywordTok{func}\NormalTok{ OrderedBy(less ...lessFunc) *multiSorter \{}
    \KeywordTok{return}\NormalTok{ &multiSorter\{}
\NormalTok{        less: less,}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{// Len is part of sort.Interface.}
\KeywordTok{func}\NormalTok{ (ms *multiSorter) Len() }\DataTypeTok{int}\NormalTok{ \{}
    \KeywordTok{return} \BuiltInTok{len}\NormalTok{(ms.wordCountPairs)}
\NormalTok{\}}

\CommentTok{// Swap is part of sort.Interface.}
\KeywordTok{func}\NormalTok{ (ms *multiSorter) Swap(i, j }\DataTypeTok{int}\NormalTok{) \{}
\NormalTok{    ms.wordCountPairs[i], ms.wordCountPairs[j] =}
\NormalTok{        ms.wordCountPairs[j], ms.wordCountPairs[i]}
\NormalTok{\}}

\CommentTok{// Less is part of sort.Interface. It is implemented by looping along the less}
\CommentTok{// functions until it finds a comparison the discriminates between the two items}
\CommentTok{// (one is less than the other).}
\KeywordTok{func}\NormalTok{ (ms *multiSorter) Less(i, j }\DataTypeTok{int}\NormalTok{) }\DataTypeTok{bool}\NormalTok{ \{}
\NormalTok{    p, q := &ms.wordCountPairs[i], &ms.wordCountPairs[j]}
    \CommentTok{// Try all but the last comparison.}
    \KeywordTok{var}\NormalTok{ k }\DataTypeTok{int}
    \KeywordTok{for}\NormalTok{ k = }\DecValTok{0}\NormalTok{; k < }\BuiltInTok{len}\NormalTok{(ms.less)-}\DecValTok{1}\NormalTok{; k++ \{}
\NormalTok{        less := ms.less[k]}
        \KeywordTok{switch}\NormalTok{ \{}
        \KeywordTok{case}\NormalTok{ less(p, q):}
            \CommentTok{// p < q, so we have a decision.}
            \KeywordTok{return} \OtherTok{true}
        \KeywordTok{case}\NormalTok{ less(q, p):}
            \CommentTok{// p > q, so we have a decision.}
            \KeywordTok{return} \OtherTok{false}
\NormalTok{        \}}
        \CommentTok{// p == q; try the next comparison.}
\NormalTok{    \}}
    \CommentTok{// All comparisons to here said "equal", so just return whatever the final}
    \CommentTok{// comparison reports.}
    \KeywordTok{return}\NormalTok{ ms.less[k](p, q)}
\NormalTok{\}}

\CommentTok{// WordCount counts words read from input (io.Reader interface) and returns the}
\CommentTok{// word-count pairs.}
\KeywordTok{func}\NormalTok{ WordCount(input io.Reader) []WordCountPair \{}
\NormalTok{    m := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{map}\NormalTok{[}\DataTypeTok{string}\NormalTok{]}\DataTypeTok{int}\NormalTok{)}
\NormalTok{    scanner := bufio.NewScanner(input)}
\NormalTok{    scanner.Split(bufio.ScanWords)}
    \KeywordTok{for}\NormalTok{ scanner.Scan() \{}
        \CommentTok{// Read a word using word scanner, trim punctuation and make it lower case.}
\NormalTok{        word := getWord(scanner.Text())}
        \CommentTok{// Increase the count. If the there was no such word in the map it uses}
        \CommentTok{// zero as its count.}
\NormalTok{        m[word]++}
\NormalTok{    \}}

    \CommentTok{// Create a slice the same length as the word-count map.}
\NormalTok{    pairs := }\BuiltInTok{make}\NormalTok{([]WordCountPair, }\BuiltInTok{len}\NormalTok{(m))}

    \CommentTok{// Fill the silce with data from the map.}
\NormalTok{    i := }\DecValTok{0}
    \KeywordTok{for}\NormalTok{ word, count := }\KeywordTok{range}\NormalTok{ m \{}
\NormalTok{        pairs[i] = WordCountPair\{Word: word, Count: count\}}
\NormalTok{        i++}
\NormalTok{    \}}

    \KeywordTok{return}\NormalTok{ pairs}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    input := strings.NewReader(Shakespeare)}
\NormalTok{    pairs := WordCount(input)}

    \CommentTok{// Closures that order the WordCountPair structure.}
\NormalTok{    word := }\KeywordTok{func}\NormalTok{(p1, p2 *WordCountPair) }\DataTypeTok{bool}\NormalTok{ \{}
        \KeywordTok{return}\NormalTok{ p1.Word < p2.Word}
\NormalTok{    \}}
\NormalTok{    count := }\KeywordTok{func}\NormalTok{(p1, p2 *WordCountPair) }\DataTypeTok{bool}\NormalTok{ \{}
        \KeywordTok{return}\NormalTok{ p1.Count > p2.Count }\CommentTok{// Note: > orders downward.}
\NormalTok{    \}}

\NormalTok{    OrderedBy(count, word).Sort(pairs)}

    \KeywordTok{for}\NormalTok{ _, pair := }\KeywordTok{range}\NormalTok{ pairs \{}
\NormalTok{        fmt.Println(pair.Word, pair.Count)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## the 6
## thy 5
## to 4
## and 3
## but 2
## by 2
## his 2
## might 2
## own 2
## self 2
## tender 2
## that 2
## thine 2
## thou 2
## world's 2
## a 1
## abundance 1
## art 1
## as 1
## be 1
## bear 1
## beauty's 1
## bright 1
## bud 1
## buriest 1
## churl 1
## content 1
## contracted 1
## creatures 1
## cruel 1
## decease 1
## desire 1
## die 1
## due 1
## eat 1
## else 1
## eyes 1
## fairest 1
## famine 1
## feed'st 1
## flame 1
## foe 1
## fresh 1
## from 1
## fuel 1
## gaudy 1
## glutton 1
## grave 1
## heir 1
## herald 1
## in 1
## increase 1
## lies 1
## light's 1
## mak'st 1
## making 1
## memory 1
## never 1
## niggarding 1
## now 1
## only 1
## or 1
## ornament 1
## pity 1
## riper 1
## rose 1
## self-substantial 1
## should 1
## spring 1
## sweet 1
## thee 1
## thereby 1
## this 1
## time 1
## too 1
## waste 1
## we 1
## where 1
## with 1
## within 1
## world 1
\end{verbatim}

\hypertarget{goroutines-and-channels}{%
\chapter{Goroutines and channels}\label{goroutines-and-channels}}

\hypertarget{what-is-goroutine}{%
\section{What is goroutine}\label{what-is-goroutine}}

\hypertarget{introduction-to-concurrency}{%
\section{Introduction to concurrency}\label{introduction-to-concurrency}}

\hypertarget{channels}{%
\section{Channels}\label{channels}}

\hypertarget{types-of-channels}{%
\section{Types of channels}\label{types-of-channels}}

\hypertarget{pipelines}{%
\section{Pipelines}\label{pipelines}}

\hypertarget{looping-in-parallel}{%
\section{Looping in parallel}\label{looping-in-parallel}}

\hypertarget{time.tick}{%
\section{\texorpdfstring{\texttt{time.Tick}}{time.Tick}}\label{time.tick}}

\hypertarget{the-select-statement}{%
\section{\texorpdfstring{The \texttt{select} statement}{The select statement}}\label{the-select-statement}}

\hypertarget{cancellation}{%
\section{Cancellation}\label{cancellation}}

\hypertarget{module-project-5}{%
\section*{Module project}\label{module-project-5}}
\addcontentsline{toc}{section}{Module project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import}\NormalTok{ (}
    \StringTok{"fmt"}
    \StringTok{"math/rand"}
    \StringTok{"sync"}
    \StringTok{"time"}
\NormalTok{)}

\KeywordTok{const}\NormalTok{ (}
\NormalTok{    NumberOfRacers   = }\DecValTok{10}
\NormalTok{    NumberOfLaps     = }\DecValTok{3}
\NormalTok{    MaxSleepDuration = }\DecValTok{3} \CommentTok{// seconds}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ init() \{}
\NormalTok{    rand.Seed(time.Now().UnixNano())}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ race(racer }\DataTypeTok{int}\NormalTok{, start }\KeywordTok{chan} \KeywordTok{struct}\NormalTok{\{\}, finish }\KeywordTok{chan} \DataTypeTok{int}\NormalTok{, status }\KeywordTok{chan}\NormalTok{ []}\DataTypeTok{int}\NormalTok{, wg *sync.WaitGroup) \{}
    \KeywordTok{defer}\NormalTok{ wg.Done()}
\NormalTok{    <-start}
    \KeywordTok{for}\NormalTok{ lap := }\DecValTok{1}\NormalTok{; lap <= NumberOfLaps; lap++ \{}
\NormalTok{        sleep := time.Duration(rand.Intn(MaxSleepDuration))}
\NormalTok{        time.Sleep(sleep * time.Second)}
        \KeywordTok{go} \KeywordTok{func}\NormalTok{(racer, lap }\DataTypeTok{int}\NormalTok{) \{}
\NormalTok{            status <- []}\DataTypeTok{int}\NormalTok{\{racer, lap\}}
\NormalTok{        \}(racer, lap)}
\NormalTok{    \}}
\NormalTok{    finish <- racer}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ main() \{}
\NormalTok{    start := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{chan} \KeywordTok{struct}\NormalTok{\{\})}
\NormalTok{    finish := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{chan} \DataTypeTok{int}\NormalTok{)}
\NormalTok{    status := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{chan}\NormalTok{ []}\DataTypeTok{int}\NormalTok{)}
\NormalTok{    done := }\BuiltInTok{make}\NormalTok{(}\KeywordTok{chan} \KeywordTok{struct}\NormalTok{\{\})}
    \KeywordTok{var}\NormalTok{ wg sync.WaitGroup}
\NormalTok{    wg.Add(NumberOfRacers)}
    \KeywordTok{for}\NormalTok{ racer := }\DecValTok{1}\NormalTok{; racer <= NumberOfRacers; racer++ \{}
        \KeywordTok{go}\NormalTok{ race(racer, start, finish, status, &wg)}
\NormalTok{    \}}

    \KeywordTok{go} \KeywordTok{func}\NormalTok{() \{}
\NormalTok{        wg.Wait()}
        \BuiltInTok{close}\NormalTok{(done)}
\NormalTok{    \}()}

\NormalTok{    startTime := time.Now()}
    \BuiltInTok{close}\NormalTok{(start)}

\NormalTok{    ticker := time.NewTicker(time.Second)}
    \KeywordTok{defer}\NormalTok{ ticker.Stop()}

    \KeywordTok{var}\NormalTok{ winners []}\DataTypeTok{int}

\NormalTok{OuterLoop:}
    \KeywordTok{for}\NormalTok{ \{}
        \KeywordTok{select}\NormalTok{ \{}
        \KeywordTok{case}\NormalTok{ t := <-ticker.C:}
\NormalTok{            fmt.Println(}\StringTok{"Race time:"}\NormalTok{, t.Sub(startTime))}
        \KeywordTok{case}\NormalTok{ s := <-status:}
\NormalTok{            fmt.Printf(}\StringTok{"Racer #%d is on lap %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, s[}\DecValTok{0}\NormalTok{], s[}\DecValTok{1}\NormalTok{])}
        \KeywordTok{case}\NormalTok{ finished := <-finish:}
\NormalTok{            fmt.Printf(}\StringTok{"Racer #%d finished!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, finished)}
            \KeywordTok{if} \BuiltInTok{len}\NormalTok{(winners) < }\DecValTok{3}\NormalTok{ \{}
\NormalTok{                winners = }\BuiltInTok{append}\NormalTok{(winners, finished)}
\NormalTok{            \}}
        \KeywordTok{case}\NormalTok{ <-done:}
            \KeywordTok{break}\NormalTok{ OuterLoop}
\NormalTok{        \}}
\NormalTok{    \}}

    \BuiltInTok{close}\NormalTok{(finish)}
    \BuiltInTok{close}\NormalTok{(status)}

\NormalTok{    fmt.Println(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Winners:"}\NormalTok{)}
\NormalTok{    place := }\DecValTok{1}
    \KeywordTok{for}\NormalTok{ _, racer := }\KeywordTok{range}\NormalTok{ winners \{}
\NormalTok{        fmt.Printf(}\StringTok{"%d place: Racer #%d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, place, racer)}
\NormalTok{        place++}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Racer #6 is on lap 1
## Racer #9 finished!
## Racer #9 is on lap 3
## Racer #9 is on lap 1
## Racer #9 is on lap 2
## Racer #10 is on lap 1
## Race time: 1.000112957s
## Racer #10 is on lap 2
## Racer #1 is on lap 2
## Racer #6 is on lap 2
## Racer #2 is on lap 2
## Racer #3 is on lap 1
## Racer #7 is on lap 1
## Racer #1 is on lap 1
## Racer #2 is on lap 1
## Race time: 2.000263709s
## Racer #2 finished!
## Racer #2 is on lap 3
## Racer #5 finished!
## Racer #4 is on lap 1
## Racer #8 is on lap 1
## Racer #5 is on lap 1
## Racer #5 is on lap 2
## Racer #5 is on lap 3
## Race time: 3.000230913s
## Racer #6 is on lap 3
## Racer #6 finished!
## Racer #10 finished!
## Racer #1 finished!
## Racer #10 is on lap 3
## Racer #1 is on lap 3
## Racer #8 finished!
## Racer #3 finished!
## Racer #7 finished!
## Racer #4 finished!
## Racer #8 is on lap 2
## Racer #8 is on lap 3
## Racer #3 is on lap 2
## 
## Winners:
## 1 place: Racer #9
## 2 place: Racer #2
## 3 place: Racer #5
\end{verbatim}

\hypertarget{course-project}{%
\chapter*{Course project}\label{course-project}}
\addcontentsline{toc}{chapter}{Course project}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import}\NormalTok{ (}
    \StringTok{"encoding/csv"}
    \StringTok{"fmt"}
    \StringTok{"io"}
    \StringTok{"log"}
    \StringTok{"os"}
    \StringTok{"strconv"}
    \StringTok{"strings"}
\NormalTok{)}

\KeywordTok{func}\NormalTok{ main() \{}
    \KeywordTok{var}\NormalTok{ input io.Reader}

    \KeywordTok{switch} \BuiltInTok{len}\NormalTok{(os.Args) \{}
    \KeywordTok{case} \DecValTok{1}\NormalTok{:}
\NormalTok{        input = os.Stdin}
    \KeywordTok{case} \DecValTok{2}\NormalTok{:}
\NormalTok{        f, err := os.Open(os.Args[}\DecValTok{1}\NormalTok{])}
        \KeywordTok{if}\NormalTok{ err != }\OtherTok{nil}\NormalTok{ \{}
\NormalTok{            log.Fatal(err)}
\NormalTok{        \}}
        \KeywordTok{defer}\NormalTok{ f.Close()}
\NormalTok{        input = f}
    \KeywordTok{default}\NormalTok{:}
\NormalTok{        log.Fatal(}\StringTok{"This program expects either 0 or 1 arguments."}\NormalTok{)}
\NormalTok{    \}}

\NormalTok{    r := csv.NewReader(input)}
\NormalTok{    r.FieldsPerRecord = }\DecValTok{-1}

\NormalTok{    records, err := r.ReadAll()}
    \KeywordTok{if}\NormalTok{ err != }\OtherTok{nil}\NormalTok{ \{}
\NormalTok{        log.Fatal(err)}
\NormalTok{    \}}

    \CommentTok{// Remove the very first "record" (i.e 'Category: All categories') if exists}
    \KeywordTok{if} \BuiltInTok{len}\NormalTok{(records[}\DecValTok{0}\NormalTok{]) == }\DecValTok{1}\NormalTok{ \{}
\NormalTok{        records = }\BuiltInTok{append}\NormalTok{(records[:}\DecValTok{0}\NormalTok{], records[}\DecValTok{1}\NormalTok{:]...)}
\NormalTok{    \}}

    \CommentTok{// Save names to a slice}
\NormalTok{    names := records[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{:] }\CommentTok{// Skip 'weeks' column}
\NormalTok{    commonSuffix := longestCommonSuffix(names)}
    \KeywordTok{if}\NormalTok{ commonSuffix != }\StringTok{""}\NormalTok{ \{}
        \KeywordTok{for}\NormalTok{ i, name := }\KeywordTok{range}\NormalTok{ names \{}
\NormalTok{            names[i] = strings.TrimSuffix(name, commonSuffix)}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    records = }\BuiltInTok{append}\NormalTok{(records[:}\DecValTok{0}\NormalTok{], records[}\DecValTok{1}\NormalTok{:]...)}

\NormalTok{    avg := }\BuiltInTok{make}\NormalTok{([]}\DataTypeTok{int}\NormalTok{, }\BuiltInTok{len}\NormalTok{(names))}

    \KeywordTok{for}\NormalTok{ _, record := }\KeywordTok{range}\NormalTok{ records \{}
\NormalTok{        record = record[}\DecValTok{1}\NormalTok{:] }\CommentTok{// Skip 'weeks' column}
        \KeywordTok{for}\NormalTok{ i, s := }\KeywordTok{range}\NormalTok{ record \{}
\NormalTok{            n, err := strconv.Atoi(s)}
            \KeywordTok{if}\NormalTok{ err != }\OtherTok{nil}\NormalTok{ \{}
\NormalTok{                log.Fatal(err)}
\NormalTok{            \}}
\NormalTok{            avg[i] += n}
\NormalTok{        \}}
\NormalTok{    \}}

    \KeywordTok{for}\NormalTok{ i := }\DecValTok{0}\NormalTok{; i < }\BuiltInTok{len}\NormalTok{(avg); i++ \{}
\NormalTok{        avg[i] = avg[i] / }\BuiltInTok{len}\NormalTok{(records)}
\NormalTok{    \}}

    \KeywordTok{for}\NormalTok{ i, n := }\KeywordTok{range}\NormalTok{ avg \{}
\NormalTok{        n = n/}\DecValTok{10}\NormalTok{ + }\DecValTok{1}
\NormalTok{        fmt.Printf(}\StringTok{"%s %s (%d)}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, strings.Repeat(}\StringTok{"▓"}\NormalTok{, n), names[i], avg[i])}
\NormalTok{    \}}
\NormalTok{\}}

\KeywordTok{func}\NormalTok{ longestCommonSuffix(a []}\DataTypeTok{string}\NormalTok{) }\DataTypeTok{string}\NormalTok{ \{}
    \KeywordTok{if} \BuiltInTok{len}\NormalTok{(a) == }\DecValTok{0}\NormalTok{ \{}
        \KeywordTok{return} \StringTok{""}
\NormalTok{    \}}

\NormalTok{    suffix := a[}\DecValTok{0}\NormalTok{]}
    \KeywordTok{if} \BuiltInTok{len}\NormalTok{(a) == }\DecValTok{1}\NormalTok{ \{}
        \KeywordTok{return}\NormalTok{ suffix}
\NormalTok{    \}}

    \KeywordTok{for}\NormalTok{ _, s := }\KeywordTok{range}\NormalTok{ a[}\DecValTok{1}\NormalTok{:] \{}
\NormalTok{        suffixLength := }\BuiltInTok{len}\NormalTok{(suffix)}
\NormalTok{        sLength := }\BuiltInTok{len}\NormalTok{(s)}

        \KeywordTok{if}\NormalTok{ suffixLength == }\DecValTok{0}\NormalTok{ || sLength == }\DecValTok{0}\NormalTok{ \{}
            \KeywordTok{return} \StringTok{""}
\NormalTok{        \}}

\NormalTok{        maxLength := suffixLength}
        \KeywordTok{if}\NormalTok{ sLength < maxLength \{}
\NormalTok{            maxLength = sLength}
\NormalTok{        \}}

        \KeywordTok{for}\NormalTok{ i := }\DecValTok{0}\NormalTok{; i < maxLength; i++ \{}
\NormalTok{            j := suffixLength - i - }\DecValTok{1}
\NormalTok{            k := sLength - i - }\DecValTok{1}
            \KeywordTok{if}\NormalTok{ suffix[j] != s[k] \{}
\NormalTok{                suffix = suffix[j+}\DecValTok{1}\NormalTok{:]}
                \KeywordTok{break}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \KeywordTok{return}\NormalTok{ suffix}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}


\end{document}
